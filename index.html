<!-- âœ… UPDATED: Global keyword search (lower-48, full coverage) -->
<script>
(function(){
  // Lower-48 states (matches your dropdown)
  const LOWER48 = [
    "AL","AR","AZ","CA","CO","CT","DE","FL","GA","IA","ID","IL","IN","KS","KY",
    "LA","MA","MD","ME","MI","MN","MO","MS","MT","NC","ND","NE","NH","NJ","NM",
    "NV","NY","OH","OK","OR","PA","RI","SC","SD","TN","TX","UT","VA","VT","WA",
    "WI","WV","WY"
  ];

  const stationIndex = []; // { id, name, state, norm }
  let building = false;
  let built = false;

  const searchInput = document.getElementById('global-search');
  const resultsBox  = document.getElementById('search-results');

  // Build the nationwide index on page load (fast, batched)
  document.addEventListener('DOMContentLoaded', buildGlobalIndex);

  async function buildGlobalIndex(){
    if (building || built) return;
    building = true;
    try {
      const batchSize = 6; // fetch 6 states at a time
      for (let i = 0; i < LOWER48.length; i += batchSize) {
        const batch = LOWER48.slice(i, i + batchSize);
        await Promise.all(batch.map(fetchStateStations));
        // stash lightweight progress (used in results header)
        resultsBox.dataset.progress = Math.min(i + batch.length, LOWER48.length);
      }
      built = true;
    } catch (e) {
      console.error('Global index build failed:', e);
    } finally {
      building = false;
    }
  }

  async function fetchStateStations(state){
    // Limit to stations with gage height param 00065 (matches your 2nd dropdown)
    const url = `https://waterservices.usgs.gov/nwis/site/?format=rdb&stateCd=${state}&parameterCd=00065&siteStatus=active`;
    const txt = await fetch(url).then(r => r.text());
    const lines = txt.split('\n');

    // Find header row (starts with 'agency_cd') then parse following data rows
    const headerIdx = lines.findIndex(l => l.startsWith('agency_cd'));
    for (let i = (headerIdx === -1 ? 0 : headerIdx + 1); i < lines.length; i++) {
      const line = lines[i];
      if (!line || line[0] === '#') continue;
      const parts = line.split('\t');
      if (parts.length < 3) continue;
      const id   = parts[1];
      const name = parts[2];
      if (!id || !name) continue;
      stationIndex.push({ id, name, state, norm: name.toLowerCase() });
    }
  }

  // Debounce helper
  function debounce(fn, ms = 120) {
    let t; return (...args) => { clearTimeout(t); t = setTimeout(() => fn(...args), ms); };
  }

  // Render results (top 150)
  function renderResults(items){
    if (!items.length) {
      resultsBox.style.display = 'none';
      resultsBox.innerHTML = '';
      return;
    }
    resultsBox.style.display = 'block';

    let html = '';
    if (!built) {
      const done = Number(resultsBox.dataset.progress || 0);
      html += `<div style="padding:6px 8px; color:#ddd;">Indexing stationsâ€¦ ${done}/${LOWER48.length}</div>`;
    }
    html += items.slice(0, 150).map(it => `
      <button type="button" data-id="${it.id}" data-state="${it.state}"
        style="display:block;width:100%;text-align:left;padding:8px 10px;margin:4px 0;
               background:#294a38;color:#ddd;border:none;border-radius:6px;cursor:pointer;">
        ${it.name} (${it.state})
      </button>
    `).join('');

    resultsBox.innerHTML = html;
    resultsBox.querySelectorAll('button').forEach(btn => {
      btn.onmouseenter = () => btn.style.background = '#3f6d4e';
      btn.onmouseleave = () => btn.style.background = '#294a38';
      btn.onclick = () => chooseStationFromSearch({
        id: btn.dataset.id, state: btn.dataset.state
      });
    });
  }

  // Search behavior (keyword match anywhere in station name or by id)
  const handleSearch = debounce(() => {
    const q = (searchInput.value || '').trim().toLowerCase();
    if (!q) {
      resultsBox.style.display = 'none';
      resultsBox.innerHTML = '';
      return;
    }
    const tokens = q.split(/\s+/).filter(Boolean);
    const res = stationIndex.filter(s =>
      tokens.every(t => s.norm.includes(t) || s.id.includes(t))
    );
    renderResults(res);
  }, 150);

  searchInput.addEventListener('focus',  () => { buildGlobalIndex(); handleSearch(); });
  searchInput.addEventListener('input',  handleSearch);

  // Close results if clicking outside
  document.addEventListener('click', (e) => {
    const wrap = document.getElementById('global-search-wrap');
    if (wrap && !wrap.contains(e.target)) resultsBox.style.display = 'none';
  });

  // Choose from search: set state, load stations, pick station, trigger your existing showChart()
  async function chooseStationFromSearch(item){
    const stateSel   = document.getElementById('state-select');
    const stationSel = document.getElementById('station-select');
    const searchBtn  = document.getElementById('search-btn');

    if (stateSel.value !== item.state) {
      stateSel.value = item.state;
      if (typeof fetchStations === 'function') {
        await fetchStations(); // your existing loader
      } else {
        stateSel.dispatchEvent(new Event('change'));
      }
    }

    // Wait for the specific station option to appear
    await waitForOption(stationSel, item.id, 15000).catch(() => {});

    stationSel.value = item.id;
    if (typeof stationSel.onchange === 'function') stationSel.onchange();
    if (searchBtn) searchBtn.disabled = false;

    // Hide results and clear input
    resultsBox.style.display = 'none';
    resultsBox.innerHTML = '';
    searchInput.value = '';

    if (typeof showChart === 'function') showChart(); // reuse your logic
  }

  function waitForOption(selectEl, value, timeoutMs = 15000) {
    return new Promise((resolve, reject) => {
      const t0 = Date.now();
      const iv = setInterval(() => {
        const found = Array.from(selectEl.options).some(o => o.value === value);
        if (found) { clearInterval(iv); resolve(true); }
        else if (Date.now() - t0 > timeoutMs) { clearInterval(iv); reject(new Error('Option not found')); }
      }, 150);
    });
  }
})();
</script>
<!-- ðŸ”š UPDATED -->
