<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>McCoy.fish</title>
  <style>
    /* ====== THEME (unchanged visuals) ====== */
    body {
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 0;
      background-image: url('mccoyfishwallpaper.jpg');
      background-size: cover;
      background-attachment: fixed;
      background-position: center;
      background-repeat: no-repeat;
      color: #d6d6d6;
    }
    header { text-align: center; padding-top: 40px; }
    header img { max-width: 160px; height: auto; }
    h1 { font-size: 3em; margin: 10px 0; color: #ccc; }

    main { padding: 20px; display: flex; flex-direction: column; align-items: center; }
    .card {
      background-color: rgba(0, 20, 10, 0.75);
      border-radius: 15px;
      box-shadow: 0 0 20px #003300;
      padding: 30px;
      width: 90%;
      max-width: 900px;
      margin-top: 20px;
    }
    .card h2 { color: #b8ffb3; text-align: center; margin-top: 0; }

    .inputs { max-width: 600px; margin: 0 auto; }
    .inputs input, .inputs select, .inputs button {
      width: 100%;
      padding: 12px;
      margin-top: 10px;
      margin-bottom: 15px;
      border-radius: 8px;
      border: none;
      font-size: 1em;
      background-color: #294a38;
      color: #ddd;
      outline: none;
    }
    .inputs button { background-color: #3f6d4e; cursor: pointer; transition: background-color 0.3s ease; }
    .inputs button:hover { background-color: #51996b; }

    /* Search results panel */
    .results {
      display: none;
      background: rgba(41,74,56,0.96);
      border: 1px solid rgba(184,255,179,0.25);
      border-radius: 10px;
      max-height: 280px;
      overflow: auto;
    }
    .result-item {
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid rgba(184,255,179,0.12);
      font-size: 0.95em;
      color: #e6ffe4;
    }
    .result-item:hover { background: rgba(81,153,107,0.25); }
    .muted { opacity: 0.85; }

    /* Loader (indeterminate to avoid flicker) */
    .loader {
      display: none;
      margin-top: -5px;
      margin-bottom: 8px;
      font-size: 0.95em;
      color: #cfe9cc;
      text-align: center;
    }
    .bar-wrap {
      height: 6px; border-radius: 6px; background: rgba(184,255,179,0.18);
      overflow: hidden; box-shadow: inset 0 0 6px rgba(0,0,0,0.25); margin-top: 8px;
    }
    .bar {
      height: 100%; width: 40%; background: #b8ffb3; filter: drop-shadow(0 0 6px #003300);
      animation: indet 1.2s linear infinite;
    }
    @keyframes indet { 0%{margin-left:-45%} 100%{margin-left:105%} }

    /* Gage section */
    .img-row img { width: 100%; height: auto; }

    /* Weather layout */
    .forecast-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
    }
    .forecast-card {
      background: rgba(41, 74, 56, 0.6);
      border: 1px solid rgba(184,255,179,0.15);
      border-radius: 12px;
      padding: 14px;
    }
    .forecast-card h4 { margin: 0 0 6px 0; color: #e1ffe0; font-weight: 600; font-size: 1.05em; }
    .forecast-line { margin: 4px 0; font-size: 0.95em; color: #dfe7df; }
    .forecast-narrative {
      margin-top: 14px; padding-top: 12px; border-top: 1px dashed rgba(184,255,179,0.25);
      color: #dfe7df; font-size: 0.98em; line-height: 1.35em;
    }
  </style>
</head>
<body>
  <header>
    <img src="mccoyfishlogo.png" alt="McCoy Fish Logo" />
    <h1>McCoy.fish</h1>
  </header>

  <main>
    <!-- Search + selectors -->
    <section class="card">
      <h2>Search Water Data</h2>
      <div class="inputs">
        <input id="q" type="text" placeholder="Type a river, creek, or station name… (e.g., Licking River)" autocomplete="off" />
        <div id="loader" class="loader">
          Loading station index…
          <div class="bar-wrap"><div class="bar"></div></div>
        </div>
        <div id="results" class="results"></div>

        <select id="state">
          <option value="">Select a state</option>
        </select>

        <select id="station" disabled>
          <option value="">Select a station</option>
        </select>

        <button id="go" disabled>Search</button>
      </div>
    </section>

    <!-- Charts -->
    <section id="charts" class="card" style="display:none;">
      <h2>Gage Height & Discharge</h2>
      <div class="img-row" id="row-00065">
        <img id="img-00065" alt="USGS Gage Height Chart" referrerpolicy="no-referrer">
      </div>
      <h2 style="margin-top: 30px;">Discharge (CFS) – Last 7 Days</h2>
      <div class="img-row" id="row-00060">
        <img id="img-00060" alt="USGS Discharge Chart" referrerpolicy="no-referrer">
      </div>
    </section>

    <!-- Weather -->
    <section id="wx" class="card" style="display:none;">
      <h2>3-Day Weather Forecast</h2>
      <div class="forecast-grid" id="wx-grid"></div>
      <div class="forecast-narrative" id="wx-note"></div>
    </section>
  </main>

  <script>
    /* ========= CONFIG ========= */
    const STATIONS_JSON_URL = '/data/stations.min.json'; // change if you host elsewhere

    /* ====== STATE ====== */
    let allStations = [];  // {id, name, state, city?}
    let byState = new Map(); // state -> array
    let indexReady = false;

    /* ====== UTILS ====== */
    const STATE_NAMES = {
      AL:"Alabama", AR:"Arkansas", AZ:"Arizona", CA:"California", CO:"Colorado", CT:"Connecticut",
      DE:"Delaware", FL:"Florida", GA:"Georgia", IA:"Iowa", ID:"Idaho", IL:"Illinois",
      IN:"Indiana", KS:"Kansas", KY:"Kentucky", LA:"Louisiana", MA:"Massachusetts", MD:"Maryland",
      ME:"Maine", MI:"Michigan", MN:"Minnesota", MO:"Missouri", MS:"Mississippi", MT:"Montana",
      NC:"North Carolina", ND:"North Dakota", NE:"Nebraska", NH:"New Hampshire", NJ:"New Jersey",
      NM:"New Mexico", NV:"Nevada", NY:"New York", OH:"Ohio", OK:"Oklahoma", OR:"Oregon",
      PA:"Pennsylvania", RI:"Rhode Island", SC:"South Carolina", SD:"South Dakota", TN:"Tennessee",
      TX:"Texas", UT:"Utah", VA:"Virginia", VT:"Vermont", WA:"Washington", WI:"Wisconsin",
      WV:"West Virginia", WY:"Wyoming"
    };
    function parseCityFromName(name, st) {
      if (!name) return '';
      const m = name.match(/\b(?:AT|NEAR|NR|ABOVE|BELOW)\s+([^,]+),\s*([A-Z]{2})\b/i);
      if (m && (!st || m[2].toUpperCase() === st.toUpperCase())) {
        return m[1].trim().replace(/\s+/g,' ');
      }
      return '';
    }
    function fmtTimeHHMM(iso) {
      if (!iso) return '—';
      const t = iso.split('T')[1] || '';
      return t ? t.slice(0,5) : '—';
    }
    function weatherDescription(code) {
      const map = {
        0:"Clear",1:"Mainly clear",2:"Partly cloudy",3:"Overcast",
        45:"Fog",48:"Rime fog",
        51:"Drizzle: Light",53:"Drizzle: Moderate",55:"Drizzle: Dense",
        56:"Freezing drizzle: Light",57:"Freezing drizzle: Dense",
        61:"Rain: Slight",63:"Rain: Moderate",65:"Rain: Heavy",
        66:"Freezing rain: Light",67:"Freezing rain: Heavy",
        71:"Snow: Slight",73:"Snow: Moderate",75:"Snow: Heavy",
        77:"Snow grains",
        80:"Rain showers: Slight",81:"Rain showers: Moderate",82:"Rain showers: Violent",
        85:"Snow showers: Slight",86:"Snow showers: Heavy",
        95:"Thunderstorm",96:"Thunderstorm w/ slight hail",99:"Thunderstorm w/ heavy hail"
      };
      return map[code] || "Unknown";
    }

    /* ====== DOM ====== */
    const qEl   = document.getElementById('q');
    const resEl = document.getElementById('results');
    const loaderEl = document.getElementById('loader');
    const stateEl = document.getElementById('state');
    const stationEl = document.getElementById('station');
    const goEl = document.getElementById('go');

    const chartsEl = document.getElementById('charts');
    const img65 = document.getElementById('img-00065');
    const img60 = document.getElementById('img-00060');
    const row65 = document.getElementById('row-00065');
    const row60 = document.getElementById('row-00060');

    const wxEl = document.getElementById('wx');
    const wxGrid = document.getElementById('wx-grid');
    const wxNote = document.getElementById('wx-note');

    /* ====== INDEX LOADING (no flicker) ====== */
    async function loadIndex() {
      loaderEl.style.display = 'block';
      try {
        const res = await fetch(STATIONS_JSON_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error('Stations JSON not found.');
        allStations = await res.json();
        if (!Array.isArray(allStations)) throw new Error('Stations JSON malformed.');

        for (const s of allStations) {
          s.state = (s.state || '').toUpperCase();
          if (!s.city) s.city = parseCityFromName(s.name || '', s.state);
          if (!byState.has(s.state)) byState.set(s.state, []);
          byState.get(s.state).push(s);
        }
        for (const [st, arr] of byState.entries()) {
          arr.sort((a,b) => (a.name||'').localeCompare(b.name||''));
        }
        const statesSorted = Array.from(byState.keys()).sort();
        for (const st of statesSorted) {
          const opt = document.createElement('option');
          opt.value = st;
          opt.textContent = STATE_NAMES[st] ? `${STATE_NAMES[st]} (${st})` : st;
          stateEl.appendChild(opt);
        }

        indexReady = true;
        loaderEl.style.display = 'none';
        goEl.disabled = stationEl.value === '';
      } catch (e) {
        loaderEl.innerHTML = 'Failed to load station index.';
        console.warn(e);
      }
    }

    /* ====== SEARCH (only after index is ready) ====== */
    qEl.addEventListener('input', () => {
      const q = qEl.value.trim().toLowerCase();
      if (!indexReady) { resEl.style.display='none'; return; }
      if (q.length < 2) { resEl.style.display='none'; return; }

      const hits = [];
      for (const s of allStations) {
        const hay = `${s.name || ''} ${s.city || ''} ${s.state || ''}`.toLowerCase();
        if (hay.includes(q)) hits.push(s);
        if (hits.length >= 120) break;
      }

      resEl.innerHTML = hits.map(s => {
        const cityPart = s.city ? ` • ${s.city}, ${s.state}` : ` • ${s.state}`;
        return `<div class="result-item" data-id="${s.id}" data-state="${s.state}">${s.name}<span class="muted">${cityPart}</span></div>`;
      }).join('') || `<div class="result-item muted">No matches.</div>`;
      resEl.style.display = 'block';
    });

    resEl.addEventListener('click', (e) => {
      const item = e.target.closest('.result-item[data-id]');
      if (!item) return;
      const st = item.getAttribute('data-state');
      const id = item.getAttribute('data-id');
      stateEl.value = st;
      populateStateStations(st, id);
      resEl.style.display = 'none';
      qEl.blur();
      goEl.disabled = false;
      runSelection();
    });

    document.addEventListener('click', (e) => {
      if (!resEl.contains(e.target) && e.target !== qEl) resEl.style.display='none';
    });

    /* ====== STATE -> STATION ====== */
    stateEl.addEventListener('change', () => {
      const st = stateEl.value;
      populateStateStations(st, '');
    });
    function populateStateStations(st, preselectId='') {
      stationEl.innerHTML = `<option value="">Select a station</option>`;
      stationEl.disabled = !st;
      goEl.disabled = true;
      if (!st) return;
      const list = byState.get(st) || [];
      for (const s of list) {
        const opt = document.createElement('option');
        opt.value = s.id;
        const cityPart = s.city ? ` • ${s.city}` : '';
        opt.textContent = `${s.name}${cityPart ? cityPart : ''}`;
        stationEl.appendChild(opt);
      }
      if (preselectId) {
        stationEl.value = preselectId;
        goEl.disabled = stationEl.value === '';
      }
    }
    stationEl.addEventListener('change', () => {
      goEl.disabled = stationEl.value === '';
    });

    goEl.addEventListener('click', runSelection);

    function runSelection() {
      const siteId = stationEl.value;
      if (!siteId) return;

      const st = stateEl.value;
      const s = (byState.get(st) || []).find(x => x.id === siteId);
      showCharts(siteId);
      const city = s?.city || parseCityFromName(s?.name || '', st) || '';
      const label = city ? `${city}, ${st}` : st;
      fetchWeather(city, st, label);
    }

    /* ---------- LIGHTWEIGHT SVG FALLBACK ---------- */
    function renderSvgLine(container, points, label) {
      const old = container.querySelector('svg[data-fallback="1"]');
      if (old) old.remove();
      if (!points || points.length < 2) return;

      const W = container.clientWidth || 800;
      const H = Math.round(W * 0.4);
      const pad = 30;
      const xs = points.map(p => +p.t);
      const ys = points.map(p => +p.v).filter(v => !Number.isNaN(v));
      const minX = Math.min(...xs), maxX = Math.max(...xs);
      const minY = Math.min(...ys), maxY = Math.max(...ys);
      const spanX = maxX - minX || 1;
      const spanY = (maxY - minY) || 1;
      const scaleX = x => pad + ((x - minX) / spanX) * (W - pad*2);
      const scaleY = y => H - pad - ((y - minY) / spanY) * (H - pad*2);

      let d = '';
      points.forEach((p, i) => {
        const x = scaleX(p.t);
        const y = scaleY(p.v);
        d += (i ? ' L ' : 'M ') + x + ' ' + y;
      });

      const svg = document.createElementNS('http://www.w3.org/2000/svg','svg');
      svg.setAttribute('viewBox', `0 0 ${W} ${H}`);
      svg.setAttribute('width', '100%');
      svg.setAttribute('height', 'auto');
      svg.setAttribute('data-fallback', '1');

      const path = document.createElementNS(svg.namespaceURI,'path');
      path.setAttribute('d', d);
      path.setAttribute('fill', 'none');
      path.setAttribute('stroke', '#b8ffb3');
      path.setAttribute('stroke-width', '2');
      path.setAttribute('stroke-linecap', 'round');
      path.setAttribute('stroke-linejoin', 'round');
      svg.appendChild(path);

      if (label) {
        const txt = document.createElementNS(svg.namespaceURI,'text');
        txt.setAttribute('x', 30);
        txt.setAttribute('y', 20);
        txt.setAttribute('fill', '#dfe7df');
        txt.setAttribute('font-size', '12');
        txt.textContent = label;
        svg.appendChild(txt);
      }
      container.appendChild(svg);
    }

    async function fetchUSGSSeries(siteId, parmCd) {
      const id = String(siteId).trim().replace(/\D/g, '');
      const url = `https://waterservices.usgs.gov/nwis/iv/?format=json&sites=${id}&parameterCd=${parmCd}&period=P7D`;
      const res = await fetch(url);
      const j = await res.json();
      const ts = j?.value?.timeSeries?.[0]?.values?.[0]?.value || [];
      return ts
        .filter(row => row?.value != null)
        .map(row => ({ t: new Date(row.dateTime).getTime(), v: parseFloat(row.value) }))
        .filter(p => !Number.isNaN(p.v) && !Number.isNaN(p.t))
        .sort((a,b) => a.t - b.t);
    }

    function wireImgWithFallback(img, container, parmCd, url, label, siteId) {
      // clear any prior fallback
      const old = container.querySelector('svg[data-fallback="1"]');
      if (old) old.remove();

      img.style.display = '';
      img.removeAttribute('data-fallback');

      const fail = async () => {
        if (img.getAttribute('data-fallback') === '1') return;
        img.setAttribute('data-fallback', '1');
        img.style.display = 'none';
        try {
          const pts = await fetchUSGSSeries(siteId, parmCd);
          renderSvgLine(container, pts, label);
        } catch (e) {
          console.warn('Fallback render failed', parmCd, e);
        }
      };

      img.onerror = fail;
      img.onload = () => {
        // Some USGS responses return a tiny/blank image but "load" succeeds.
        const w = img.naturalWidth || 0;
        const h = img.naturalHeight || 0;
        if (w < 10 || h < 10) {
          fail();
          return;
        }
        // good image; ensure fallback removed
        const old2 = container.querySelector('svg[data-fallback="1"]');
        if (old2) old2.remove();
        img.style.display = '';
      };

      // cache-bust so we don't reuse a previous tiny/blank response
      img.src = `${url}${url.includes('?') ? '&' : '?'}_=${Date.now()}`;
    }

    /* ====== USGS CHARTS (PNG first, SVG fallback on error or tiny image) ====== */
    function showCharts(siteId) {
      if (!siteId) return;
      chartsEl.style.display = 'block';

      const cleanId = String(siteId).trim().replace(/\D/g, '');
      const today = new Date();
      const endDate = today.toISOString().split('T')[0];
      const past = new Date(); past.setDate(today.getDate() - 7);
      const startDate = past.toISOString().split('T')[0];

      const url65 = `https://waterdata.usgs.gov/nwisweb/graph?agency_cd=USGS&site_no=${cleanId}&parm_cd=00065&period=7`;
      const url60 = `https://waterdata.usgs.gov/nwisweb/graph?agency_cd=USGS&site_no=${cleanId}&parm_cd=00060&begin_date=${startDate}&end_date=${endDate}`;

      wireImgWithFallback(
        img65, row65, '00065', url65, 'Gage height (ft) – last 7 days', cleanId
      );
      wireImgWithFallback(
        img60, row60, '00060', url60, 'Discharge (cfs) – last 7 days', cleanId
      );
    }

    /* ====== WEATHER via City+State ====== */
    async function fetchWeather(city, state, label) {
      wxEl.style.display = 'block';
      wxGrid.innerHTML = '';
      wxNote.textContent = 'Fetching weather…';

      let q = state ? (city ? `${city}, ${state}` : state) : (city || '');
      try {
        const geo = await fetch(`https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(q)}&count=1&language=en&format=json`);
        const gj = await geo.json();
        const best = gj?.results?.[0];
        if (!best) throw new Error('No geocode match');

        const lat = best.latitude, lon = best.longitude;

        const url = new URL('https://api.open-meteo.com/v1/forecast');
        url.searchParams.set('latitude', lat);
        url.searchParams.set('longitude', lon);
        url.searchParams.set('timezone', 'auto');
        url.searchParams.set('temperature_unit', 'fahrenheit');
        url.searchParams.set('precipitation_unit', 'inch');
        url.searchParams.set('pressure_unit', 'hPa');
        url.searchParams.set('wind_speed_unit', 'mph');
        url.searchParams.set('forecast_days', '3');
        url.searchParams.set('daily', 'temperature_2m_max,temperature_2m_min,sunrise,sunset,weathercode,precipitation_probability_max,precipitation_sum,wind_speed_10m_max');
        url.searchParams.set('hourly', 'pressure_msl');

        const r2 = await fetch(url.toString());
        const data = await r2.json();
        if (!data?.daily?.time) throw new Error('Weather unavailable');

        const pTimes = data?.hourly?.time || [];
        const pVals  = data?.hourly?.pressure_msl || [];
        const avgInHg = data.daily.time.map(dayStr => {
          let total=0, cnt=0;
          for (let i=0;i<pTimes.length;i++) {
            if (pTimes[i].startsWith(dayStr)) { total+=pVals[i]; cnt++; }
          }
          const hPa = cnt ? total/cnt : null;
          return hPa ? (hPa/33.8639).toFixed(2) : '—';
        });

        const { time, temperature_2m_max: tMax, temperature_2m_min: tMin,
                sunrise, sunset, weathercode: wCode, precipitation_probability_max: pProb,
                precipitation_sum: pSum, wind_speed_10m_max: windMax } = data.daily;

        wxGrid.innerHTML = '';
        const parts = [];
        for (let i=0;i<time.length;i++) {
          const dateLabel = new Date(time[i]).toLocaleDateString([], { weekday:'short', month:'short', day:'numeric' });
          const desc = weatherDescription(wCode[i]);
          const hi = Math.round(tMax[i]), lo = Math.round(tMin[i]);
          const prob = (pProb?.[i] ?? '—');
          const precip = (pSum?.[i] ?? '—');
          const wind = (windMax?.[i] ?? '—');
          wxGrid.innerHTML += `
            <div class="forecast-card">
              <h4>${dateLabel}</h4>
              <div class="forecast-line">Sky: ${desc}</div>
              <div class="forecast-line">High / Low: ${hi}°F / ${lo}°F</div>
              <div class="forecast-line">Barometric Pressure: ${avgInHg[i]} inHg</div>
              <div class="forecast-line">Wind (max): ${wind === '—' ? '—' : wind + ' mph'}</div>
              <div class="forecast-line">Sunrise: ${fmtTimeHHMM(sunrise[i])} • Sunset: ${fmtTimeHHMM(sunset[i])}</div>
              <div class="forecast-line">Precip: ${precip} in (Max Prob: ${prob === '—' ? '—' : prob + '%'})</div>
            </div>
          `;
          parts.push(`${i===0?'Today':i===1?'Tomorrow':dateLabel}: ${desc.toLowerCase()} high near ${hi}°F, low around ${lo}°F, avg pressure ~${avgInHg[i]} inHg, wind up to ${wind === '—' ? 'N/A' : wind + ' mph'}, precip ${precip} in (max prob ${prob === '—' ? 'N/A' : prob + '%'}).`);
        }
        wxNote.innerHTML = `<strong>Outlook ${label ? 'near ' + label : ''}:</strong> ${parts.join(' ')}`;
      } catch (e) {
        wxGrid.innerHTML = '';
        wxNote.textContent = 'Weather forecast not available.';
        console.warn(e);
      }
    }

    /* ====== BOOT ====== */
    document.addEventListener('DOMContentLoaded', loadIndex);
  </script>
</body>
</html>
