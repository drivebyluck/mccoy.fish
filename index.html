<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>McCoy.fish</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 0;
      background-image: url('mccoyfishwallpaper.jpg');
      background-size: cover;
      background-attachment: fixed;
      background-position: center;
      background-repeat: no-repeat;
      color: #d6d6d6;
    }
    header {
      text-align: center;
      padding-top: 40px;
    }
    header img {
      max-width: 160px;
      height: auto;
    }
    h1 {
      font-size: 3em;
      margin: 10px 0;
      color: #ccc;
    }
    main {
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .search-section {
      background-color: rgba(0, 20, 10, 0.75);
      border-radius: 15px;
      box-shadow: 0 0 20px #003300;
      padding: 30px;
      width: 90%;
      max-width: 600px;
      margin-top: 20px;
    }
    .search-section h2 {
      text-align: center;
      font-size: 1.7em;
      color: #b8ffb3;
      margin-bottom: 20px;
    }
    .search-section input,
    .search-section select,
    .search-section button {
      width: 100%;
      padding: 12px;
      margin-top: 10px;
      margin-bottom: 15px;
      border-radius: 8px;
      border: none;
      font-size: 1em;
      background-color: #294a38;
      color: #ddd;
    }
    .search-section button {
      background-color: #3f6d4e;
      cursor: pointer;
      transition: background-color 0.3s ease;
    }
    .search-section button:hover {
      background-color: #51996b;
    }
    .gage-section {
      background-color: rgba(0, 20, 10, 0.75);
      border-radius: 15px;
      box-shadow: 0 0 20px #003300;
      padding: 30px;
      width: 90%;
      max-width: 600px;
      margin-top: 20px;
      display: none;
    }
    .gage-section h2 {
      color: #b8ffb3;
      text-align: center;
    }
    footer {
      text-align: center;
      padding: 30px 0 20px 0;
      font-size: 0.9em;
      color: #ccc;
    }

    /* ADDED: Weather banner styles (theme-matched) */
    .forecast-section {
      background-color: rgba(0, 20, 10, 0.75);
      border-radius: 15px;
      box-shadow: 0 0 20px #003300;
      padding: 24px;
      width: 90%;
      max-width: 900px;
      margin-top: 20px;
      display: none;
    }
    .forecast-title {
      color: #b8ffb3;
      text-align: center;
      margin: 0 0 16px 0;
      font-size: 1.6em;
    }
    .forecast-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
    }
    .forecast-card {
      background: rgba(41, 74, 56, 0.6);
      border: 1px solid rgba(184,255,179,0.15);
      border-radius: 12px;
      padding: 14px;
    }
    .forecast-card h4 {
      margin: 0 0 6px 0;
      color: #e1ffe0;
      font-weight: 600;
      font-size: 1.05em;
    }
    .forecast-line {
      margin: 4px 0;
      font-size: 0.95em;
      color: #dfe7df;
    }
    .forecast-narrative {
      margin-top: 14px;
      padding-top: 12px;
      border-top: 1px dashed rgba(184,255,179,0.25);
      color: #dfe7df;
      font-size: 0.98em;
      line-height: 1.35em;
    }

    /* ADDED: Global search UI */
    .global-search-wrap {
      margin-top: 8px;
    }
    .global-results {
      background: rgba(41, 74, 56, 0.96);
      border: 1px solid rgba(184,255,179,0.25);
      box-shadow: 0 0 16px #003300;
      border-radius: 10px;
      max-height: 280px;
      overflow: auto;
      display: none;
    }
    .global-result-item {
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid rgba(184,255,179,0.12);
      font-size: 0.95em;
      color: #e6ffe4;
    }
    .global-result-item:hover {
      background: rgba(81,153,107,0.25);
    }
    .global-results .empty {
      padding: 10px 12px;
      color: #dfe7df;
      opacity: 0.9;
    }
    .hint {
      font-size: 0.9em;
      color: #cfe9cc;
      opacity: 0.9;
      margin-top: -6px;
      margin-bottom: 10px;
      text-align: center;
    }
  </style>
</head>
<body>
  <header>
    <img src="mccoyfishlogo.png" alt="McCoy Fish Logo" />
    <h1>McCoy.fish</h1>
  </header>

  <main>
    <section class="search-section">
      <h2>Search Water Data</h2>

      <!-- ADDED: Global river search (keeps your dropdowns intact) -->
      <div class="global-search-wrap">
        <input id="global-search" type="text" placeholder="Type a river, creek, or station name from any state…" autocomplete="off">
        <div class="hint">Start typing to search every USGS station in every state. BE PATIENT AND WAIT MOMENTARILY AS RESULTS WILL UPDATE SLOWLY AS THEY BEGIN TO POPULATE. Select a result to auto load charts and weather.</div>
        <div id="global-results" class="global-results"></div>
      </div>
      <!-- /ADDED -->

      <select id="state-select" onchange="fetchStations()">
        <option value="">Select a state</option>
        <option value="AL">Alabama</option><option value="AR">Arkansas</option><option value="AZ">Arizona</option>
        <option value="CA">California</option><option value="CO">Colorado</option><option value="CT">Connecticut</option>
        <option value="DE">Delaware</option><option value="FL">Florida</option><option value="GA">Georgia</option>
        <option value="IA">Iowa</option><option value="ID">Idaho</option><option value="IL">Illinois</option>
        <option value="IN">Indiana</option><option value="KS">Kansas</option><option value="KY">Kentucky</option>
        <option value="LA">Louisiana</option><option value="MA">Massachusetts</option><option value="MD">Maryland</option>
        <option value="ME">Maine</option><option value="MI">Michigan</option><option value="MN">Minnesota</option>
        <option value="MO">Missouri</option><option value="MS">Mississippi</option><option value="MT">Montana</option>
        <option value="NC">North Carolina</option><option value="ND">North Dakota</option><option value="NE">Nebraska</option>
        <option value="NH">New Hampshire</option><option value="NJ">New Jersey</option><option value="NM">New Mexico</option>
        <option value="NV">Nevada</option><option value="NY">New York</option><option value="OH">Ohio</option>
        <option value="OK">Oklahoma</option><option value="OR">Oregon</option><option value="PA">Pennsylvania</option>
        <option value="RI">Rhode Island</option><option value="SC">South Carolina</option><option value="SD">South Dakota</option>
        <option value="TN">Tennessee</option><option value="TX">Texas</option><option value="UT">Utah</option>
        <option value="VA">Virginia</option><option value="VT">Vermont</option><option value="WA">Washington</option>
        <option value="WI">Wisconsin</option><option value="WV">West Virginia</option><option value="WY">Wyoming</option>
      </select>

      <select id="station-select" disabled>
        <option value="">Select a station</option>
      </select>

      <button onclick="showChart()" id="search-btn" disabled>Search</button>
    </section>

    <section class="gage-section" id="chart-section">
      <h2>Gage Height Chart</h2>
      <img id="usgs-chart-img" style="width: 100%; height: auto;" alt="USGS Gage Height Chart" />
      
      <h2 style="margin-top: 30px;">Discharge (CFS) – Last 7 Days</h2>
      <img id="usgs-discharge-img" style="width: 100%; height: auto;" alt="USGS Discharge Chart" />
    </section>

    <!-- ADDED: 3-Day Weather Banner -->
    <section class="forecast-section" id="forecast-section">
      <h3 class="forecast-title">3-Day Weather Forecast</h3>
      <div class="forecast-grid" id="forecast-grid"></div>
      <div class="forecast-narrative" id="forecast-narrative"></div>
    </section>
    <!-- /ADDED -->

  </main>

  <script>
    async function fetchStations() {
      const state = document.getElementById("state-select").value;
      const stationSelect = document.getElementById("station-select");
      const searchBtn = document.getElementById("search-btn");

      stationSelect.innerHTML = '<option value="">Loading stations...</option>';
      stationSelect.disabled = true;
      searchBtn.disabled = true;

      if (!state) return;

      const response = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=rdb&stateCd=${state}&parameterCd=00065`);
      const text = await response.text();

      const lines = text.split('\n').filter(line => !line.startsWith('#') && line.trim() && !line.startsWith('agency_cd'));
      let stations = lines.map(line => {
        const parts = line.split('\t');
        return { id: parts[1], name: parts[2] };
      });

      // Sort stations alphabetically by name
      stations.sort((a, b) => a.name.localeCompare(b.name));

      stationSelect.innerHTML = '<option value="">Select a station</option>';
      stations.forEach(station => {
        const option = document.createElement('option');
        option.value = station.id;
        option.textContent = station.name;
        stationSelect.appendChild(option);
      });

      stationSelect.disabled = false;
      stationSelect.onchange = () => {
        searchBtn.disabled = stationSelect.value === "";
      };
    }

function showChart() {
  const siteId = document.getElementById("station-select").value;
  if (!siteId) return;

  const chartSection = document.getElementById("chart-section");
  chartSection.style.display = 'block';

  // Dates
  const today = new Date();
  const endDate = today.toISOString().split('T')[0];

  const past = new Date();
  past.setDate(today.getDate() - 7);
  const startDate = past.toISOString().split('T')[0];

  // Gage Height Chart
  const chartImg = document.getElementById("usgs-chart-img");
  chartImg.src = `https://waterdata.usgs.gov/nwisweb/graph?agency_cd=USGS&site_no=${siteId}&parm_cd=00065&period=7`;

  // Discharge Chart with correct date range
  const dischargeImg = document.getElementById("usgs-discharge-img");
  dischargeImg.src = `https://waterdata.usgs.gov/nwisweb/graph?agency_cd=USGS&site_no=${siteId}&parm_cd=00060&begin_date=${startDate}&end_date=${endDate}`;
}

  </script>

  <!-- ADDED: Forecast script (runs alongside your existing onclick) -->
  <script>
    // Run our forecast loader after your existing showChart via an extra click listener.
    document.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('search-btn');
      if (btn) {
        btn.addEventListener('click', loadForecastForSelectedStation);
      }
    });

    async function loadForecastForSelectedStation() {
      const siteId = document.getElementById('station-select').value;
      if (!siteId) return;

      // 1) Get lat/lon for the selected station (USGS site service JSON).
      let lat = null, lon = null, stationName = '';
      try {
        const metaRes = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=json&sites=${siteId}`);
        const meta = await metaRes.json();
        const s = (meta?.value?.timeSeries?.[0]?.sourceInfo) || (meta?.value?.site?.[0]); // fallback shapes
        if (s?.geoLocation?.geogLocation) {
          lat = s.geoLocation.geogLocation.latitude;
          lon = s.geoLocation.geogLocation.longitude;
        } else if (s?.location?.latitude && s?.location?.longitude) {
          lat = s.location.latitude;
          lon = s.location.longitude;
        }
        stationName = s?.siteName || '';
      } catch (e) {
        console.warn('USGS site metadata fetch failed:', e);
      }
      if (lat === null || lon === null) {
        showForecastError('Unable to determine station location for weather.');
        return;
      }

      // 2) Pull 3-day weather from Open-Meteo (Fahrenheit + local timezone).
      //    We’ll compute average barometric pressure per day from hourly pressure.
      const url = new URL('https://api.open-meteo.com/v1/forecast');
      url.searchParams.set('latitude', lat);
      url.searchParams.set('longitude', lon);
      url.searchParams.set('timezone', 'auto');
      url.searchParams.set('temperature_unit', 'fahrenheit');
      url.searchParams.set('pressure_unit', 'hPa');
      url.searchParams.set('precipitation_unit', 'inch');
      url.searchParams.set('forecast_days', '3');
      url.searchParams.set('daily', 'temperature_2m_max,temperature_2m_min,sunrise,sunset,weathercode,precipitation_probability_max,precipitation_sum');
      url.searchParams.set('hourly', 'pressure_msl');

      let data;
      try {
        const res = await fetch(url.toString());
        data = await res.json();
      } catch (e) {
        console.warn('Weather fetch failed:', e);
        showForecastError('Unable to load weather forecast.');
        return;
      }

      if (!data?.daily?.time) {
        showForecastError('Weather forecast not available.');
        return;
      }

      // 3) Build the UI.
      const section = document.getElementById('forecast-section');
      const grid = document.getElementById('forecast-grid');
      const narrative = document.getElementById('forecast-narrative');

      grid.innerHTML = '';
      narrative.innerHTML = '';
      section.style.display = 'block';

      const { time, temperature_2m_max: tMax, temperature_2m_min: tMin, sunrise, sunset, weathercode: wCode, precipitation_probability_max: pProb, precipitation_sum: pSum } = data.daily;

      // Average pressure per day from hourly series.
      const pressureTimes = data?.hourly?.time || [];
      const pressureVals = data?.hourly?.pressure_msl || [];
      const dayAvgPressureInHg = time.map((dayStr) => {
        let total = 0, count = 0;
        for (let i = 0; i < pressureTimes.length; i++) {
          if (pressureTimes[i].startsWith(dayStr)) {
            total += pressureVals[i];
            count++;
          }
        }
        const hPa = count ? total / count : null;
        // convert hPa -> inHg
        return hPa ? (hPa / 33.8639).toFixed(2) : '—';
      });

      // Cards + narrative
      const pieces = [];
      for (let i = 0; i < time.length; i++) {
        const dateLabel = new Date(time[i]).toLocaleDateString([], { weekday: 'short', month: 'short', day: 'numeric' });
        const code = wCode[i];
        const desc = weatherDescription(code);
        const prob = (pProb?.[i] ?? '—');
        const precip = (pSum?.[i] ?? '—');
        const pressureInHg = dayAvgPressureInHg[i];

        grid.innerHTML += `
          <div class="forecast-card">
            <h4>${dateLabel}</h4>
            <div class="forecast-line">Sky: ${desc}</div>
            <div class="forecast-line">High / Low: ${Math.round(tMax[i])}°F / ${Math.round(tMin[i])}°F</div>
            <div class="forecast-line">Barometric Pressure: ${pressureInHg} inHg</div>
            <div class="forecast-line">Sunrise: ${fmtTime(sunrise[i])} &nbsp;•&nbsp; Sunset: ${fmtTime(sunset[i])}</div>
            <div class="forecast-line">Precip: ${precip} in &nbsp; (Max Prob: ${prob === '—' ? '—' : prob + '%'})</div>
          </div>
        `;

        pieces.push(`${i === 0 ? 'Today' : i === 1 ? 'Tomorrow' : dateLabel}: ${desc.toLowerCase()} with a high near ${Math.round(tMax[i])}°F and a low around ${Math.round(tMin[i])}°F. Average barometric pressure ~${pressureInHg} inHg. Precipitation total ${precip} in (max probability ${prob === '—' ? 'N/A' : prob + '%'}). Sunrise ${fmtTime(sunrise[i])}, sunset ${fmtTime(sunset[i])}.`);
      }

      const locText = stationName ? ` near <strong>${stationName}</strong>` : '';
      narrative.innerHTML = `<strong>Outlook${locText}:</strong> ${pieces.join(' ')}`;
    }

    function showForecastError(msg) {
      const section = document.getElementById('forecast-section');
      const grid = document.getElementById('forecast-grid');
      const narrative = document.getElementById('forecast-narrative');
      grid.innerHTML = '';
      narrative.innerHTML = msg || 'Weather unavailable.';
      section.style.display = 'block';
    }

    function fmtTime(iso) {
      try {
        return new Date(iso).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch { return '—'; }
    }

    function weatherDescription(code) {
      const map = {
        0:"Clear",1:"Mainly clear",2:"Partly cloudy",3:"Overcast",
        45:"Fog",48:"Rime fog",
        51:"Drizzle: Light",53:"Drizzle: Moderate",55:"Drizzle: Dense",
        56:"Freezing drizzle: Light",57:"Freezing drizzle: Dense",
        61:"Rain: Slight",63:"Rain: Moderate",65:"Rain: Heavy",
        66:"Freezing rain: Light",67:"Freezing rain: Heavy",
        71:"Snow: Slight",73:"Snow: Moderate",75:"Snow: Heavy",
        77:"Snow grains",
        80:"Rain showers: Slight",81:"Rain showers: Moderate",82:"Rain showers: Violent",
        85:"Snow showers: Slight",86:"Snow showers: Heavy",
        95:"Thunderstorm",96:"Thunderstorm w/ slight hail",99:"Thunderstorm w/ heavy hail"
      };
      return map[code] || "Unknown";
    }
  </script>
  <!-- /ADDED -->

  <!-- ADDED: Global search logic that leaves your original code untouched -->
  <script>
    // State codes to crawl for the global index
    const __ALL_STATES = ["AL","AR","AZ","CA","CO","CT","DE","FL","GA","IA","ID","IL","IN","KS","KY","LA","MA","MD","ME","MI","MN","MO","MS","MT","NC","ND","NE","NH","NJ","NM","NV","NY","OH","OK","OR","PA","RI","SC","SD","TN","TX","UT","VA","VT","WA","WI","WV","WY"];
    let __globalStations = []; // {id, name, state}
    let __globalIndexBuilt = false;
    let __buildingIndex = false;

    // Build index lazily on first focus or first keystroke
    document.addEventListener('DOMContentLoaded', () => {
      const input = document.getElementById('global-search');
      const box = document.getElementById('global-results');
      if (!input) return;

      input.addEventListener('focus', ensureGlobalIndex);
      input.addEventListener('input', () => {
        ensureGlobalIndex();
        renderGlobalMatches(input.value.trim());
      });

      // Close results if clicking outside
      document.addEventListener('click', (e) => {
        if (!box.contains(e.target) && e.target !== input) {
          box.style.display = 'none';
        }
      });
    });

    async function ensureGlobalIndex() {
      if (__globalIndexBuilt || __buildingIndex) return;
      __buildingIndex = true;

      const resultsBox = document.getElementById('global-results');
      resultsBox.style.display = 'block';
      resultsBox.innerHTML = '<div class="empty">Loading stations from all states…</div>';

      // Fetch in small batches to be friendly
      const batchSize = 6;
      const stateBatches = [];
      for (let i = 0; i < __ALL_STATES.length; i += batchSize) {
        stateBatches.push(__ALL_STATES.slice(i, i + batchSize));
      }

      try {
        for (const group of stateBatches) {
          await Promise.all(group.map(async (st) => {
            const url = `https://waterservices.usgs.gov/nwis/site/?format=rdb&stateCd=${st}&parameterCd=00065`;
            const res = await fetch(url);
            const text = await res.text();
            const lines = text.split('\n').filter(line => !line.startsWith('#') && line.trim() && !line.startsWith('agency_cd'));
            const rows = lines.map(line => {
              const p = line.split('\t');
              return { id: p[1], name: p[2], state: st };
            });
            __globalStations.push(...rows);
          }));
          // Give the UI a chance to update
          await new Promise(r => setTimeout(r, 40));
          resultsBox.innerHTML = '<div class="empty">Indexing… ' + __globalStations.length.toLocaleString() + ' stations loaded</div>';
        }
        // Sort once for consistent search results
        __globalStations.sort((a, b) => a.name.localeCompare(b.name));
        __globalIndexBuilt = true;
        renderGlobalMatches(document.getElementById('global-search').value.trim());
      } catch (e) {
        resultsBox.innerHTML = '<div class="empty">Problem loading stations. Try again.</div>';
        console.warn('Global index build error:', e);
      } finally {
        __buildingIndex = false;
      }
    }

    function renderGlobalMatches(query) {
      const box = document.getElementById('global-results');
      if (!box) return;

      if (!query) {
        box.style.display = 'none';
        return;
      }
      box.style.display = 'block';

      let matches = [];
      if (__globalStations.length) {
        const q = query.toLowerCase();
        matches = __globalStations.filter(s => (s.name || '').toLowerCase().includes(q)).slice(0, 80);
      }

      if (!matches.length) {
        box.innerHTML = '<div class="empty">No matches yet. Keep typing.</div>';
        return;
      }

      box.innerHTML = '';
      for (const m of matches) {
        const div = document.createElement('div');
        div.className = 'global-result-item';
        div.textContent = `${m.name}  [${m.state}]`;
        div.addEventListener('click', () => handleGlobalPick(m));
        box.appendChild(div);
      }
    }

    // Populate the native dropdowns to mirror the same selection path, then run your existing actions
    async function handleGlobalPick(station) {
      try {
        await loadStationsForState(station.state);        // fill station dropdown for that state without touching your original function
        const stationSelect = document.getElementById('station-select');
        const searchBtn = document.getElementById('search-btn');
        stationSelect.value = station.id;                 // select the station
        searchBtn.disabled = stationSelect.value === "";  // enable button
        // Trigger your existing flows
        searchBtn.click();
      } catch (e) {
        console.warn('Global pick failed:', e);
      } finally {
        const box = document.getElementById('global-results');
        if (box) box.style.display = 'none';
      }
    }

    // This helper duplicates the logic of your fetchStations, but targets a specific state and returns when the dropdown is ready.
    // Your original fetchStations remains untouched.
    async function loadStationsForState(state) {
      const stateSelect = document.getElementById('state-select');
      const stationSelect = document.getElementById('station-select');
      const searchBtn = document.getElementById('search-btn');

      if (stateSelect.value !== state) {
        stateSelect.value = state;
      }

      stationSelect.innerHTML = '<option value="">Loading stations...</option>';
      stationSelect.disabled = true;
      searchBtn.disabled = true;

      const response = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=rdb&stateCd=${state}&parameterCd=00065`);
      const text = await response.text();

      const lines = text.split('\n').filter(line => !line.startsWith('#') && line.trim() && !line.startsWith('agency_cd'));
      let stations = lines.map(line => {
        const parts = line.split('\t');
        return { id: parts[1], name: parts[2] };
      });

      stations.sort((a, b) => a.name.localeCompare(b.name));

      stationSelect.innerHTML = '<option value="">Select a station</option>';
      stations.forEach(station => {
        const option = document.createElement('option');
        option.value = station.id;
        option.textContent = station.name;
        stationSelect.appendChild(option);
      });

      stationSelect.disabled = false;
      stationSelect.onchange = () => {
        searchBtn.disabled = stationSelect.value === "";
      };
      return true;
    }
  </script>

  <script>
async function __resolveLatLon(siteId) {
  // Try the site service first
  try {
    const r1 = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=json&sites=${siteId}`);
    const j1 = await r1.json();
    const s1 = (j1?.value?.site?.[0]) || (j1?.value?.timeSeries?.[0]?.sourceInfo);
    const g1 = s1?.geoLocation?.geogLocation;
    if (g1?.latitude != null && g1?.longitude != null) {
      return { lat: g1.latitude, lon: g1.longitude, name: s1?.siteName || '' };
    }
  } catch {}

  // Fallback to the instantaneous-values endpoint which often includes coords
  try {
    const r2 = await fetch(`https://waterservices.usgs.gov/nwis/iv/?format=json&sites=${siteId}&parameterCd=00065`);
    const j2 = await r2.json();
    const s2 = j2?.value?.timeSeries?.[0]?.sourceInfo;
    const g2 = s2?.geoLocation?.geogLocation;
    if (g2?.latitude != null && g2?.longitude != null) {
      return { lat: g2.latitude, lon: g2.longitude, name: s2?.siteName || '' };
    }
  } catch {}

  return { lat: null, lon: null, name: '' };
}
</script>

  <!-- /ADDED -->

  <!-- ADDED: Robust USGS place resolution + weather fallback (no changes to your code) -->
  <script>
    // State name map for friendly labels
    const __STATE_NAME = {
      AL:"Alabama", AR:"Arkansas", AZ:"Arizona", CA:"California", CO:"Colorado", CT:"Connecticut",
      DE:"Delaware", FL:"Florida", GA:"Georgia", IA:"Iowa", ID:"Idaho", IL:"Illinois",
      IN:"Indiana", KS:"Kansas", KY:"Kentucky", LA:"Louisiana", MA:"Massachusetts", MD:"Maryland",
      ME:"Maine", MI:"Michigan", MN:"Minnesota", MO:"Missouri", MS:"Mississippi", MT:"Montana",
      NC:"North Carolina", ND:"North Dakota", NE:"Nebraska", NH:"New Hampshire", NJ:"New Jersey",
      NM:"New Mexico", NV:"Nevada", NY:"New York", OH:"Ohio", OK:"Oklahoma", OR:"Oregon",
      PA:"Pennsylvania", RI:"Rhode Island", SC:"South Carolina", SD:"South Dakota", TN:"Tennessee",
      TX:"Texas", UT:"Utah", VA:"Virginia", VT:"Vermont", WA:"Washington", WI:"Wisconsin",
      WV:"West Virginia", WY:"Wyoming"
    };

    // Pull lat/lon + state/county/siteName using JSON first, then RDB expanded as fallback
    async function __getUsgsMeta(siteId) {
      let meta = { lat:null, lon:null, siteName:"", stateCd:"", countyCd:"" };

      // JSON
      try {
        const r = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=json&sites=${siteId}`);
        const j = await r.json();
        const s = (j?.value?.site?.[0]) || (j?.value?.timeSeries?.[0]?.sourceInfo);
        if (s) {
          meta.siteName = s.siteName || meta.siteName;
          const sp = s?.siteProperty || [];
          meta.stateCd = sp.find(p=>p.name==="stateCd")?.value || meta.stateCd;
          meta.countyCd = sp.find(p=>p.name==="countyCd")?.value || meta.countyCd;
          const g = s?.geoLocation?.geogLocation;
          if (g?.latitude != null && g?.longitude != null) {
            meta.lat = g.latitude; meta.lon = g.longitude;
          }
        }
      } catch {}

      // RDB expanded fallback
      if (meta.lat == null || meta.lon == null || !meta.stateCd || !meta.countyCd) {
        try {
          const r2 = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=rdb&sites=${siteId}&siteOutput=expanded`);
          const txt = await r2.text();
          const header = txt.split("\n").find(L => L.startsWith("agency_cd"));
          const dataLine = txt.split("\n").find(L => L && !L.startsWith("#") && !L.startsWith("agency_cd"));
          if (header && dataLine) {
            const H = {}; header.split("\t").forEach((h,i)=>H[h]=i);
            const cols = dataLine.split("\t");
            const get = k => (H[k] != null ? cols[H[k]] : "");
            const decLat = parseFloat(get("dec_lat_va"));
            const decLon = parseFloat(get("dec_long_va"));
            if (!isNaN(decLat) && !isNaN(decLon)) { meta.lat = decLat; meta.lon = decLon; }
            meta.stateCd = meta.stateCd || get("state_cd");
            meta.countyCd = meta.countyCd || get("county_cd");
            meta.siteName = meta.siteName || get("station_nm");
          }
        } catch {}
      }
      return meta;
    }

    // Prefer city parsed from siteName; else county name via USGS codes; else state
    async function __friendlyPlace(meta) {
      const st = (meta.stateCd || "").toUpperCase();
      // Parse "AT CITY, ST" or "NEAR CITY, ST" style names
      let city = "";
      if (meta.siteName) {
        const m = meta.siteName.match(/\b(?:AT|NEAR|NR|ABOVE|BELOW)\s+([^,]+),\s*([A-Z]{2})\b/i);
        if (m && m[2].toUpperCase() === st) city = m[1].trim().replace(/\s+/g," ");
      }
      if (city) return `${city}, ${st}`;

      if (meta.countyCd && st) {
        try {
          const r = await fetch(`https://help.waterdata.usgs.gov/code/county_query?fmt=json&state_cd=${st}`);
          const j = await r.json();
          const rec = j?.codes?.find(c => c.value === meta.countyCd);
          if (rec?.name) return `${rec.name} County, ${st}`;
        } catch {}
      }
      return __STATE_NAME[st] ? __STATE_NAME[st] : (st || "");
    }

    // Build the same 3-day cards your code uses, but driven by a known lat/lon and friendly label
    async function __renderForecast(lat, lon, friendlyLoc) {
      const section = document.getElementById('forecast-section');
      const grid = document.getElementById('forecast-grid');
      const narrative = document.getElementById('forecast-narrative');
      if (!section || !grid || !narrative) return;

      const url = new URL('https://api.open-meteo.com/v1/forecast');
      url.searchParams.set('latitude', lat);
      url.searchParams.set('longitude', lon);
      url.searchParams.set('timezone', 'auto');
      url.searchParams.set('temperature_unit', 'fahrenheit');
      url.searchParams.set('pressure_unit', 'hPa');
      url.searchParams.set('precipitation_unit', 'inch');
      url.searchParams.set('forecast_days', '3');
      url.searchParams.set('daily', 'temperature_2m_max,temperature_2m_min,sunrise,sunset,weathercode,precipitation_probability_max,precipitation_sum');
      url.searchParams.set('hourly', 'pressure_msl');

      let data;
      try {
        const res = await fetch(url.toString());
        data = await res.json();
      } catch {
        showForecastError('Unable to load weather forecast.');
        return;
      }
      if (!data?.daily?.time) { showForecastError('Weather forecast not available.'); return; }

      section.style.display = 'block';
      grid.innerHTML = '';
      narrative.innerHTML = '';

      const { time, temperature_2m_max: tMax, temperature_2m_min: tMin, sunrise, sunset, weathercode: wCode, precipitation_probability_max: pProb, precipitation_sum: pSum } = data.daily;
      const pTimes = data?.hourly?.time || [];
      const pVals = data?.hourly?.pressure_msl || [];
      const dayAvgInHg = time.map(dayStr => {
        let total=0, cnt=0;
        for (let i=0;i<pTimes.length;i++) if (pTimes[i].startsWith(dayStr)) { total+=pVals[i]; cnt++; }
        const hPa = cnt ? total/cnt : null;
        return hPa ? (hPa/33.8639).toFixed(2) : '—';
      });

      const pieces = [];
      for (let i=0;i<time.length;i++) {
        const dateLabel = new Date(time[i]).toLocaleDateString([], { weekday:'short', month:'short', day:'numeric' });
        const desc = weatherDescription(wCode[i]);
        const prob = (pProb?.[i] ?? '—');
        const precip = (pSum?.[i] ?? '—');
        const pinhg = dayAvgInHg[i];

        grid.innerHTML += `
          <div class="forecast-card">
            <h4>${dateLabel}</h4>
            <div class="forecast-line">Sky: ${desc}</div>
            <div class="forecast-line">High / Low: ${Math.round(tMax[i])}°F / ${Math.round(tMin[i])}°F</div>
            <div class="forecast-line">Barometric Pressure: ${pinhg} inHg</div>
            <div class="forecast-line">Sunrise: ${fmtTime(sunrise[i])} &nbsp;•&nbsp; Sunset: ${fmtTime(sunset[i])}</div>
            <div class="forecast-line">Precip: ${precip} in &nbsp; (Max Prob: ${prob === '—' ? '—' : prob + '%'})</div>
          </div>
        `;
        pieces.push(`${i===0?'Today':i===1?'Tomorrow':dateLabel}: ${desc.toLowerCase()} with a high near ${Math.round(tMax[i])}°F and a low around ${Math.round(tMin[i])}°F. Average barometric pressure ~${pinhg} inHg. Precipitation total ${precip} in (max probability ${prob==='—'?'N/A':prob+'%'}). Sunrise ${fmtTime(sunrise[i])}, sunset ${fmtTime(sunset[i])}.`);
      }
      const label = friendlyLoc ? ` near <strong>${friendlyLoc}</strong>` : '';
      narrative.innerHTML = `<strong>Outlook${label}:</strong> ${pieces.join(' ')}`;
    }

    // After your original weather function runs, if it left the error message, run our fallback
    async function __forecastFallbackIfNeeded() {
      const narrative = document.getElementById('forecast-narrative');
      const grid = document.getElementById('forecast-grid');
      const siteId = document.getElementById('station-select')?.value;
      if (!siteId) return;

      // Only engage if your original script showed the specific error or left nothing rendered
      const errorShown = !!narrative && /Unable to determine station location for weather\./i.test(narrative.innerText || '');
      const emptyGrid = !!grid && grid.children.length === 0;

      if (!errorShown && !emptyGrid) return;

      try {
        const meta = await __getUsgsMeta(siteId);
        if (meta.lat == null || meta.lon == null) return;
        const place = await __friendlyPlace(meta);
        await __renderForecast(meta.lat, meta.lon, place);
      } catch (e) {
        console.warn('Forecast fallback failed:', e);
      }
    }

    // Hook our fallback AFTER your existing click handlers run
    document.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('search-btn');
      if (!btn) return;
      btn.addEventListener('click', () => {
        // Let your original handler run first, then check
        setTimeout(__forecastFallbackIfNeeded, 600);
      });
    });
  </script>
  <!-- /ADDED -->

</body>
</html>

