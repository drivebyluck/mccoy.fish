<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>McCoy.fish</title>
  <style>
    /* ====== THEME (unchanged visuals) ====== */
    body {
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 0;
      background-image: url('mccoyfishwallpaper.jpg');
      background-size: cover;
      background-attachment: fixed;
      background-position: center;
      background-repeat: no-repeat;
      color: #d6d6d6;
    }
    header { text-align: center; padding-top: 40px; }
    header img { max-width: 160px; height: auto; }
    h1 { font-size: 3em; margin: 10px 0; color: #ccc; }

    main { padding: 20px; display: flex; flex-direction: column; align-items: center; }
    .card {
      background-color: rgba(0, 20, 10, 0.75);
      border-radius: 15px;
      box-shadow: 0 0 20px #003300;
      padding: 30px;
      width: 90%;
      max-width: 900px;
      margin-top: 20px;
    }
    .card h2 { color: #b8ffb3; text-align: center; margin-top: 0; }

    .inputs { max-width: 600px; margin: 0 auto; }
    .inputs input, .inputs select, .inputs button {
      width: 100%;
      padding: 12px;
      margin-top: 10px;
      margin-bottom: 15px;
      border-radius: 8px;
      border: none;
      font-size: 1em;
      background-color: #294a38;
      color: #ddd;
      outline: none;
    }
    .inputs button { background-color: #3f6d4e; cursor: pointer; transition: background-color 0.3s ease; }
    .inputs button:hover { background-color: #51996b; }

    /* Search results panel */
    .results {
      display: none;
      background: rgba(41,74,56,0.96);
      border: 1px solid rgba(184,255,179,0.25);
      border-radius: 10px;
      max-height: 280px;
      overflow: auto;
    }
    .result-item {
      padding: 10px 12px;
      cursor: pointer;
      border-bottom: 1px solid rgba(184,255,179,0.12);
      font-size: 0.95em;
      color: #e6ffe4;
    }
    .result-item:hover { background: rgba(81,153,107,0.25); }
    .muted { opacity: 0.85; }

    /* Loader (indeterminate to avoid flicker) */
    .loader {
      display: none;
      margin-top: -5px;
      margin-bottom: 8px;
      font-size: 0.95em;
      color: #cfe9cc;
      text-align: center;
    }
    .bar-wrap {
      height: 6px; border-radius: 6px; background: rgba(184,255,179,0.18);
      overflow: hidden; box-shadow: inset 0 0 6px rgba(0,0,0,0.25); margin-top: 8px;
    }
    .bar {
      height: 100%; width: 40%; background: #b8ffb3; filter: drop-shadow(0 0 6px #003300);
      animation: indet 1.2s linear infinite;
    }
    @keyframes indet { 0%{margin-left:-45%} 100%{margin-left:105%} }

    /* Gage section */
    .img-row img { width: 100%; height: auto; }

    /* Weather layout */
    .forecast-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
      gap: 12px;
    }
    .forecast-card {
      background: rgba(41, 74, 56, 0.6);
      border: 1px solid rgba(184,255,179,0.15);
      border-radius: 12px;
      padding: 14px;
    }
    .forecast-card h4 { margin: 0 0 6px 0; color: #e1ffe0; font-weight: 600; font-size: 1.05em; }
    .forecast-line { margin: 4px 0; font-size: 0.95em; color: #dfe7df; }
    .forecast-narrative {
      margin-top: 14px; padding-top: 12px; border-top: 1px dashed rgba(184,255,179,0.25);
      color: #dfe7df; font-size: 0.98em; line-height: 1.35em;
    }
  </style>
</head>
<body>
  <header>
    <img src="mccoyfishlogo.png" alt="McCoy Fish Logo" />
    <h1>McCoy.fish</h1>
  </header>

  <main>
    <!-- Search + selectors -->
    <section class="card">
      <h2>Search Water Data</h2>
      <div class="inputs">
        <input id="q" type="text" placeholder="Type a river, creek, or station name… (e.g., Licking River)" autocomplete="off" />
        <div id="loader" class="loader">
          Loading station index…
          <div class="bar-wrap"><div class="bar"></div></div>
        </div>
        <div id="results" class="results"></div>

        <select id="state">
          <option value="">Select a state</option>
        </select>

        <select id="station" disabled>
          <option value="">Select a station</option>
        </select>

        <button id="go" disabled>Search</button>
      </div>
    </section>

    <!-- Charts -->
    <section id="charts" class="card" style="display:none;">
      <h2>Gage Height & Discharge</h2>
      <div class="img-row">
        <img id="img-00065" alt="USGS Gage Height Chart" referrerpolicy="no-referrer">
      </div>
      <h2 style="margin-top: 30px;">Discharge (CFS) – Last 7 Days</h2>
      <div class="img-row">
        <img id="img-00060" alt="USGS Discharge Chart" referrerpolicy="no-referrer">
      </div>
    </section>

    <!-- Weather -->
    <section id="wx" class="card" style="display:none;">
      <h2>3-Day Weather Forecast</h2>
      <div class="forecast-grid" id="wx-grid"></div>
      <div class="forecast-narrative" id="wx-note"></div>
    </section>
  </main>

  <script>
    /* ========= CONFIG ========= */
    const STATIONS_JSON_URL = '/data/stations.min.json'; // your local JSON index

    /* ====== STATE ====== */
    let allStations = [];   // {id, name, state, city?, (maybe) lat/lon?}
    let byState = new Map();
    let indexReady = false;

    /* ====== UTILS ====== */
    const STATE_NAMES = {
      AL:"Alabama", AR:"Arkansas", AZ:"Arizona", CA:"California", CO:"Colorado", CT:"Connecticut",
      DE:"Delaware", FL:"Florida", GA:"Georgia", IA:"Iowa", ID:"Idaho", IL:"Illinois",
      IN:"Indiana", KS:"Kansas", KY:"Kentucky", LA:"Louisiana", MA:"Massachusetts", MD:"Maryland",
      ME:"Maine", MI:"Michigan", MN:"Minnesota", MO:"Missouri", MS:"Mississippi", MT:"Montana",
      NC:"North Carolina", ND:"North Dakota", NE:"Nebraska", NH:"New Hampshire", NJ:"New Jersey",
      NM:"New Mexico", NV:"Nevada", NY:"New York", OH:"Ohio", OK:"Oklahoma", OR:"Oregon",
      PA:"Pennsylvania", RI:"Rhode Island", SC:"South Carolina", SD:"South Dakota", TN:"Tennessee",
      TX:"Texas", UT:"Utah", VA:"Virginia", VT:"Vermont", WA:"Washington", WI:"Wisconsin",
      WV:"West Virginia", WY:"Wyoming"
    };

    // Keep leading zeros from JSON for charts
    function normalizeSiteId(raw) {
      let s = (raw == null ? '' : String(raw)).trim();
      s = s.replace(/\D/g, '');
      if (s.length < 8) s = s.padStart(8, '0');
      return s;
    }

    function parseCityFromName(name, st) {
      if (!name) return '';
      const m = name.match(/\b(?:AT|NEAR|NR|ABOVE|BELOW)\s+([^,]+),\s*([A-Z]{2})\b/i);
      if (m && (!st || m[2].toUpperCase() === st.toUpperCase())) {
        return m[1].trim().replace(/\s+/g,' ');
      }
      return '';
    }
    function fmtTimeHHMM(iso) {
      if (!iso) return '—';
      const t = iso.split('T')[1] || '';
      return t ? t.slice(0,5) : '—';
    }
    function weatherDescription(code) {
      const map = {0:"Clear",1:"Mainly clear",2:"Partly cloudy",3:"Overcast",45:"Fog",48:"Rime fog",51:"Drizzle: Light",53:"Drizzle: Moderate",55:"Drizzle: Dense",56:"Freezing drizzle: Light",57:"Freezing drizzle: Dense",61:"Rain: Slight",63:"Rain: Moderate",65:"Rain: Heavy",66:"Freezing rain: Light",67:"Freezing rain: Heavy",71:"Snow: Slight",73:"Snow: Moderate",75:"Snow: Heavy",77:"Snow grains",80:"Rain showers: Slight",81:"Rain showers: Moderate",82:"Rain showers: Violent",85:"Snow showers: Slight",86:"Snow showers: Heavy",95:"Thunderstorm",96:"Thunderstorm w/ slight hail",99:"Thunderstorm w/ heavy hail"};
      return map[code] || "Unknown";
    }

    /* ====== DOM ====== */
    const qEl   = document.getElementById('q');
    const resEl = document.getElementById('results');
    const loaderEl = document.getElementById('loader');
    const stateEl = document.getElementById('state');
    const stationEl = document.getElementById('station');
    const goEl = document.getElementById('go');

    const chartsEl = document.getElementById('charts');
    const img65 = document.getElementById('img-00065');
    const img60 = document.getElementById('img-00060');

    const wxEl = document.getElementById('wx');
    const wxGrid = document.getElementById('wx-grid');
    const wxNote = document.getElementById('wx-note');

    /* ====== INDEX LOADING ====== */
    async function loadIndex() {
      loaderEl.style.display = 'block';
      try {
        const res = await fetch(STATIONS_JSON_URL, { cache: 'no-store' });
        if (!res.ok) throw new Error('Stations JSON not found.');
        allStations = await res.json();
        if (!Array.isArray(allStations)) throw new Error('Stations JSON malformed.');

        for (const s of allStations) {
          s.id = normalizeSiteId(s.id ?? s.site_no ?? s.code ?? s.number);
          s.state = (s.state || '').toUpperCase();
          if (!s.city) s.city = parseCityFromName(s.name || '', s.state);
          if (!byState.has(s.state)) byState.set(s.state, []);
          byState.get(s.state).push(s);
        }

        for (const [st, arr] of byState.entries()) arr.sort((a,b) => (a.name||'').localeCompare(b.name||''));
        for (const st of Array.from(byState.keys()).sort()) {
          const opt = document.createElement('option');
          opt.value = st;
          opt.textContent = STATE_NAMES[st] ? `${STATE_NAMES[st]} (${st})` : st;
          stateEl.appendChild(opt);
        }

        indexReady = true;
        loaderEl.style.display = 'none';
        goEl.disabled = stationEl.value === '';
      } catch (e) {
        loaderEl.innerHTML = 'Failed to load station index.';
        console.warn(e);
      }
    }

    /* ====== SEARCH ====== */
    qEl.addEventListener('input', () => {
      const q = qEl.value.trim().toLowerCase();
      if (!indexReady) { resEl.style.display='none'; return; }
      if (q.length < 2) { resEl.style.display='none'; return; }

      const hits = [];
      for (const s of allStations) {
        const hay = `${s.name || ''} ${s.city || ''} ${s.state || ''}`.toLowerCase();
        if (hay.includes(q)) hits.push(s);
        if (hits.length >= 120) break;
      }

      resEl.innerHTML = hits.map(s => {
        const cityPart = s.city ? ` • ${s.city}, ${s.state}` : ` • ${s.state}`;
        return `<div class="result-item" data-id="${s.id}" data-state="${s.state}">${s.name}<span class="muted">${cityPart}</span></div>`;
      }).join('') || `<div class="result-item muted">No matches.</div>`;
      resEl.style.display = 'block';
    });

    resEl.addEventListener('click', (e) => {
      const item = e.target.closest('.result-item[data-id]');
      if (!item) return;
      const st = item.getAttribute('data-state');
      const id = item.getAttribute('data-id');
      stateEl.value = st;
      populateStateStations(st, id);
      resEl.style.display = 'none';
      qEl.blur();
      goEl.disabled = false;
      runSelection();
    });

    document.addEventListener('click', (e) => {
      if (!resEl.contains(e.target) && e.target !== qEl) resEl.style.display='none';
    });

    /* ====== STATE -> STATION ====== */
    stateEl.addEventListener('change', () => {
      const st = stateEl.value;
      populateStateStations(st, '');
    });
    function populateStateStations(st, preselectId='') {
      stationEl.innerHTML = `<option value="">Select a station</option>`;
      stationEl.disabled = !st;
      goEl.disabled = true;
      if (!st) return;
      const list = byState.get(st) || [];
      for (const s of list) {
        const opt = document.createElement('option');
        opt.value = s.id;
        const cityPart = s.city ? ` • ${s.city}` : '';
        opt.textContent = `${s.name}${cityPart ? cityPart : ''}`;
        stationEl.appendChild(opt);
      }
      if (preselectId) {
        stationEl.value = preselectId;
        goEl.disabled = stationEl.value === '';
      }
    }
    stationEl.addEventListener('change', () => {
      goEl.disabled = stationEl.value === '';
    });

    goEl.addEventListener('click', runSelection);

    function runSelection() {
      const siteId = stationEl.value;
      if (!siteId) return;

      const st = stateEl.value;
      const s = (byState.get(st) || []).find(x => x.id === siteId);

      // Charts (unchanged)
      showCharts(siteId);

      // Weather label from JSON, but location via USGS coordinates
      const city = (s?.city || '').trim();
      const label = city ? `${city}, ${st}` : st;
      fetchWeather(label, s); // pass label + station record for JSON lat/lon fallback
    }

    /* ====== USGS CHARTS ====== */
    function showCharts(siteId) {
      if (!siteId) return;
      chartsEl.style.display = 'block';

      const today = new Date();
      const endDate = today.toISOString().split('T')[0];
      const past = new Date(); past.setDate(today.getDate() - 7);
      const startDate = past.toISOString().split('T')[0];

      img65.src = `https://waterdata.usgs.gov/nwisweb/graph?agency_cd=USGS&site_no=${siteId}&parm_cd=00065&period=7`;
      img60.src = `https://waterdata.usgs.gov/nwisweb/graph?agency_cd=USGS&site_no=${siteId}&parm_cd=00060&begin_date=${startDate}&end_date=${endDate}`;
    }

    /* ====== WEATHER (USGS RDB coords -> Open-Meteo; JSON coords fallback; last-resort geocode) ====== */
    async function fetchWeather(label, stationRec) {
      wxEl.style.display = 'block';
      wxGrid.innerHTML = '';
      wxNote.textContent = 'Fetching weather…';

      const siteId = stationEl.value;
      let lat = null, lon = null, place = label || '';

      // 1) Try USGS RDB "expanded" for precise coordinates
      try {
        const r = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=rdb&sites=${siteId}&siteOutput=expanded`);
        const txt = await r.text();
        const lines = txt.split('\n').filter(L => L.trim() && !L.startsWith('#'));
        // find header row and the first data row after it
        const headerIdx = lines.findIndex(L => L.startsWith('agency_cd'));
        if (headerIdx >= 0 && headerIdx + 1 < lines.length) {
          const header = lines[headerIdx].split('\t');
          // find the first data line (skip any repeated headers)
          const dataLine = lines.slice(headerIdx + 1).find(L => !L.startsWith('agency_cd'));
          if (dataLine) {
            const cols = dataLine.split('\t');
            const H = Object.fromEntries(header.map((h,i)=>[h,i]));
            const la = parseFloat(cols[H['dec_lat_va']]);
            const lo = parseFloat(cols[H['dec_long_va']]);
            if (!isNaN(la) && !isNaN(lo)) {
              lat = la; lon = lo;
            }
            // use station name if present
            if (!place && H['station_nm']) place = cols[H['station_nm']];
          }
        }
      } catch (e) {
        console.warn('USGS RDB coordinate fetch failed:', e);
      }

      // 2) Fallback: coordinates embedded in your local JSON (if any fields exist)
      if (lat == null || lon == null) {
        const candLat = stationRec?.lat ?? stationRec?.latitude ?? stationRec?.dec_lat_va ?? stationRec?.lat_dd;
        const candLon = stationRec?.lon ?? stationRec?.longitude ?? stationRec?.dec_long_va ?? stationRec?.lon_dd;
        const la = parseFloat(candLat), lo = parseFloat(candLon);
        if (!isNaN(la) && !isNaN(lo)) { lat = la; lon = lo; }
      }

      // 3) Last resort: geocode the label (rarely needed now)
      if (lat == null || lon == null) {
        try {
          const geoURL = `https://geocoding-api.open-meteo.com/v1/search?name=${encodeURIComponent(place)}&count=1&language=en&format=json`;
          const geo = await fetch(geoURL);
          const gj = await geo.json();
          const best = gj?.results?.[0];
          if (best) { lat = best.latitude; lon = best.longitude; }
        } catch (e) {
          console.warn('Geocoding fallback failed:', e);
        }
      }

      if (lat == null || lon == null) {
        wxGrid.innerHTML = '';
        wxNote.textContent = 'Weather forecast not available (no coordinates).';
        return;
      }

      // 4) Open-Meteo forecast (3-day) with daily avg pressure from hourly
      try {
        const url = new URL('https://api.open-meteo.com/v1/forecast');
        url.searchParams.set('latitude', lat);
        url.searchParams.set('longitude', lon);
        url.searchParams.set('timezone', 'auto');
        url.searchParams.set('temperature_unit', 'fahrenheit');
        url.searchParams.set('precipitation_unit', 'inch');
        url.searchParams.set('pressure_unit', 'hPa');
        url.searchParams.set('wind_speed_unit', 'mph');
        url.searchParams.set('forecast_days', '3');
        url.searchParams.set('daily', 'temperature_2m_max,temperature_2m_min,sunrise,sunset,weathercode,precipitation_probability_max,precipitation_sum,wind_speed_10m_max');
        url.searchParams.set('hourly', 'pressure_msl');

        const r2 = await fetch(url.toString());
        const data = await r2.json();
        if (!data?.daily?.time) throw new Error('Weather unavailable');

        const pTimes = data?.hourly?.time || [];
        const pVals  = data?.hourly?.pressure_msl || [];
        const avgInHg = data.daily.time.map(dayStr => {
          let total=0, cnt=0;
          for (let i=0;i<pTimes.length;i++) if (pTimes[i].startsWith(dayStr)) { total+=pVals[i]; cnt++; }
          const hPa = cnt ? total/cnt : null;
          return hPa ? (hPa/33.8639).toFixed(2) : '—';
        });

        const { time, temperature_2m_max: tMax, temperature_2m_min: tMin,
                sunrise, sunset, weathercode: wCode, precipitation_probability_max: pProb,
                precipitation_sum: pSum, wind_speed_10m_max: windMax } = data.daily;

        wxGrid.innerHTML = '';
        const parts = [];
        for (let i=0;i<time.length;i++) {
          const dateLabel = new Date(time[i]).toLocaleDateString([], { weekday:'short', month:'short', day:'numeric' });
          const desc = weatherDescription(wCode[i]);
          const hi = Math.round(tMax[i]), lo = Math.round(tMin[i]);
          const prob = (pProb?.[i] ?? '—');
          const precip = (pSum?.[i] ?? '—');
          const wind = (windMax?.[i] ?? '—');
          wxGrid.innerHTML += `
            <div class="forecast-card">
              <h4>${dateLabel}</h4>
              <div class="forecast-line">Sky: ${desc}</div>
              <div class="forecast-line">High / Low: ${hi}°F / ${lo}°F</div>
              <div class="forecast-line">Barometric Pressure: ${avgInHg[i]} inHg</div>
              <div class="forecast-line">Wind (max): ${wind === '—' ? '—' : wind + ' mph'}</div>
              <div class="forecast-line">Sunrise: ${fmtTimeHHMM(sunrise[i])} • Sunset: ${fmtTimeHHMM(sunset[i])}</div>
              <div class="forecast-line">Precip: ${precip} in (Max Prob: ${prob === '—' ? '—' : prob + '%'})</div>
            </div>
          `;
          parts.push(`${i===0?'Today':i===1?'Tomorrow':dateLabel}: ${desc.toLowerCase()} high near ${hi}°F, low around ${lo}°F, avg pressure ~${avgInHg[i]} inHg, wind up to ${wind === '—' ? 'N/A' : wind + ' mph'}, precip ${precip} in (max prob ${prob === '—' ? 'N/A' : prob + '%'}).`);
        }

        wxNote.innerHTML = `<strong>Outlook ${place ? 'near ' + place : ''}:</strong> ${parts.join(' ')}`;
      } catch (e) {
        console.warn('Weather fetch failed:', e);
        wxGrid.innerHTML = '';
        wxNote.textContent = 'Weather forecast not available.';
      }
    }

    /* ====== BOOT ====== */
    document.addEventListener('DOMContentLoaded', loadIndex);
  </script>
</body>
</html>
