<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>McCoy.fish</title>
  <style>
    body {
      font-family: 'Courier New', monospace;
      margin: 0;
      padding: 0;
      background-image: url('mccoyfishwallpaper.jpg');
      background-size: cover;
      background-attachment: fixed;
      background-position: center;
      background-repeat: no-repeat;
      color: #d6d6d6;
    }
    header { text-align: center; padding-top: 40px; }
    header img { max-width: 160px; height: auto; }
    h1 { font-size: 3em; margin: 10px 0; color: #ccc; }

    main { padding: 20px; display: flex; flex-direction: column; align-items: center; }

    .search-section {
      background-color: rgba(0, 20, 10, 0.75);
      border-radius: 15px;
      box-shadow: 0 0 20px #003300;
      padding: 30px;
      width: 90%;
      max-width: 600px;
      margin-top: 20px;
    }
    .search-section h2 { text-align: center; font-size: 1.7em; color: #b8ffb3; margin-bottom: 20px; }
    .search-section input,
    .search-section select,
    .search-section button {
      width: 100%;
      padding: 12px;
      margin-top: 10px;
      margin-bottom: 15px;
      border-radius: 8px;
      border: none;
      font-size: 1em;
      background-color: #294a38;
      color: #ddd;
    }
    .search-section button { background-color: #3f6d4e; cursor: pointer; transition: background-color 0.3s ease; }
    .search-section button:hover { background-color: #51996b; }

    .gage-section {
      background-color: rgba(0, 20, 10, 0.75);
      border-radius: 15px;
      box-shadow: 0 0 20px #003300;
      padding: 30px;
      width: 90%;
      max-width: 600px;
      margin-top: 20px;
      display: none;
    }
    .gage-section h2 { color: #b8ffb3; text-align: center; }

    footer { text-align: center; padding: 30px 0 20px 0; font-size: 0.9em; color: #ccc; }

    /* Weather banner */
    .forecast-section {
      background-color: rgba(0, 20, 10, 0.75);
      border-radius: 15px;
      box-shadow: 0 0 20px #003300;
      padding: 24px;
      width: 90%;
      max-width: 900px;
      margin-top: 20px;
      display: none;
    }
    .forecast-title { color: #b8ffb3; text-align: center; margin: 0 0 16px 0; font-size: 1.6em; }
    .forecast-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; }
    .forecast-card {
      background: rgba(41, 74, 56, 0.6);
      border: 1px solid rgba(184,255,179,0.15);
      border-radius: 12px;
      padding: 14px;
    }
    .forecast-card h4 { margin: 0 0 6px 0; color: #e1ffe0; font-weight: 600; font-size: 1.05em; }
    .forecast-line { margin: 4px 0; font-size: 0.95em; color: #dfe7df; }
    .forecast-narrative {
      margin-top: 14px; padding-top: 12px;
      border-top: 1px dashed rgba(184,255,179,0.25);
      color: #dfe7df; font-size: 0.98em; line-height: 1.35em;
    }

    /* Global search UI (unchanged visuals) */
    .global-search-wrap { margin-top: 8px; }
    .global-results {
      background: rgba(41, 74, 56, 0.96);
      border: 1px solid rgba(184,255,179,0.25);
      box-shadow: 0 0 16px #003300;
      border-radius: 10px;
      max-height: 280px;
      overflow: auto;
      display: none;
    }
    .global-result-item { padding: 10px 12px; cursor: pointer; border-bottom: 1px solid rgba(184,255,179,0.12); font-size: 0.95em; color: #e6ffe4; }
    .global-result-item:hover { background: rgba(81,153,107,0.25); }
    .global-results .empty { padding: 10px 12px; color: #dfe7df; opacity: 0.9; }
    .hint { font-size: 0.9em; color: #cfe9cc; opacity: 0.9; margin-top: -6px; margin-bottom: 10px; text-align: center; }

    /* Loader (progress + ETA) */
    #global-progress { display: none; padding: 8px 10px 6px 10px; position: sticky; top: 0; background: rgba(41, 74, 56, 0.96); border-bottom: 1px solid rgba(184,255,179,0.20); z-index: 2; }
    .mccoy-progress-wrap { height: 6px; border-radius: 6px; background: rgba(184,255,179,0.18); overflow: hidden; box-shadow: inset 0 0 6px rgba(0,0,0,0.25); }
    .mccoy-progress-bar { height: 100%; width: 0%; background: #b8ffb3; filter: drop-shadow(0 0 6px #003300); transition: width .15s linear; }
    .mccoy-progress-text { margin-top: 6px; font-size: 0.9em; color: #dfe7df; opacity: 0.9; text-align: center; }
  </style>
</head>
<body>
  <header>
    <img src="mccoyfishlogo.png" alt="McCoy Fish Logo" />
    <h1>McCoy.fish</h1>
  </header>

  <main>
    <section class="search-section">
      <h2>Search Water Data</h2>

      <!-- Global river search -->
      <div class="global-search-wrap">
        <input id="global-search" type="text" placeholder="Type a river, creek, or station name from any state…" autocomplete="off">
        <div class="hint">Results appear after the station index fully loads. You’ll see progress and an ETA below.</div>
        <div id="global-results" class="global-results"></div>
      </div>

      <select id="state-select" onchange="fetchStations()">
        <option value="">Select a state</option>
        <option value="AL">Alabama</option><option value="AR">Arkansas</option><option value="AZ">Arizona</option>
        <option value="CA">California</option><option value="CO">Colorado</option><option value="CT">Connecticut</option>
        <option value="DE">Delaware</option><option value="FL">Florida</option><option value="GA">Georgia</option>
        <option value="IA">Iowa</option><option value="ID">Idaho</option><option value="IL">Illinois</option>
        <option value="IN">Indiana</option><option value="KS">Kansas</option><option value="KY">Kentucky</option>
        <option value="LA">Louisiana</option><option value="MA">Massachusetts</option><option value="MD">Maryland</option>
        <option value="ME">Maine</option><option value="MI">Michigan</option><option value="MN">Minnesota</option>
        <option value="MO">Missouri</option><option value="MS">Mississippi</option><option value="MT">Montana</option>
        <option value="NC">North Carolina</option><option value="ND">North Dakota</option><option value="NE">Nebraska</option>
        <option value="NH">New Hampshire</option><option value="NJ">New Jersey</option><option value="NM">New Mexico</option>
        <option value="NV">Nevada</option><option value="NY">New York</option><option value="OH">Ohio</option>
        <option value="OK">Oklahoma</option><option value="OR">Oregon</option><option value="PA">Pennsylvania</option>
        <option value="RI">Rhode Island</option><option value="SC">South Carolina</option><option value="SD">South Dakota</option>
        <option value="TN">Tennessee</option><option value="TX">Texas</option><option value="UT">Utah</option>
        <option value="VA">Virginia</option><option value="VT">Vermont</option><option value="WA">Washington</option>
        <option value="WI">Wisconsin</option><option value="WV">West Virginia</option><option value="WY">Wyoming</option>
      </select>

      <select id="station-select" disabled>
        <option value="">Select a station</option>
      </select>

      <button onclick="showChart()" id="search-btn" disabled>Search</button>
    </section>

    <section class="gage-section" id="chart-section">
      <h2>Gage Height Chart</h2>
      <img id="usgs-chart-img" style="width: 100%; height: auto;" alt="USGS Gage Height Chart" />
      <h2 style="margin-top: 30px;">Discharge (CFS) – Last 7 Days</h2>
      <img id="usgs-discharge-img" style="width: 100%; height: auto;" alt="USGS Discharge Chart" />
    </section>

    <section class="forecast-section" id="forecast-section">
      <h3 class="forecast-title">3-Day Weather Forecast</h3>
      <div class="forecast-grid" id="forecast-grid"></div>
      <div class="forecast-narrative" id="forecast-narrative"></div>
    </section>
  </main>

  <!-- Keep your charts logic (unchanged) -->
  <script>
    async function fetchStations() {
      const state = document.getElementById("state-select").value;
      const stationSelect = document.getElementById("station-select");
      const searchBtn = document.getElementById("search-btn");

      stationSelect.innerHTML = '<option value="">Loading stations...</option>';
      stationSelect.disabled = true;
      searchBtn.disabled = true;

      if (!state) return;

      const response = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=rdb&stateCd=${state}&parameterCd=00065`);
      const text = await response.text();

      const lines = text.split('\n').filter(line => !line.startsWith('#') && line.trim() && !line.startsWith('agency_cd'));
      let stations = lines.map(line => {
        const parts = line.split('\t');
        return { id: parts[1], name: parts[2] };
      });

      stations.sort((a, b) => a.name.localeCompare(b.name));

      stationSelect.innerHTML = '<option value="">Select a station</option>';
      stations.forEach(station => {
        const option = document.createElement('option');
        option.value = station.id;
        option.textContent = station.name;
        stationSelect.appendChild(option);
      });

      stationSelect.disabled = false;
      stationSelect.onchange = () => {
        searchBtn.disabled = stationSelect.value === "";
      };
    }

    function showChart() {
      const siteId = document.getElementById("station-select").value;
      if (!siteId) return;

      const chartSection = document.getElementById("chart-section");
      chartSection.style.display = 'block';

      const today = new Date();
      const endDate = today.toISOString().split('T')[0];

      const past = new Date();
      past.setDate(today.getDate() - 7);
      const startDate = past.toISOString().split('T')[0];

      const chartImg = document.getElementById("usgs-chart-img");
      chartImg.src = `https://waterdata.usgs.gov/nwisweb/graph?agency_cd=USGS&site_no=${siteId}&parm_cd=00065&period=7`;

      const dischargeImg = document.getElementById("usgs-discharge-img");
      dischargeImg.src = `https://waterdata.usgs.gov/nwisweb/graph?agency_cd=USGS&site_no=${siteId}&parm_cd=00060&begin_date=${startDate}&end_date=${endDate}`;
    }
  </script>

  <!-- WEATHER (uses City+State via geocoding) -->
  <script>
    const STATE_NAME = {
      AL:"Alabama", AR:"Arkansas", AZ:"Arizona", CA:"California", CO:"Colorado", CT:"Connecticut", DE:"Delaware",
      FL:"Florida", GA:"Georgia", IA:"Iowa", ID:"Idaho", IL:"Illinois", IN:"Indiana", KS:"Kansas", KY:"Kentucky",
      LA:"Louisiana", MA:"Massachusetts", MD:"Maryland", ME:"Maine", MI:"Michigan", MN:"Minnesota", MO:"Missouri",
      MS:"Mississippi", MT:"Montana", NC:"North Carolina", ND:"North Dakota", NE:"Nebraska", NH:"New Hampshire",
      NJ:"New Jersey", NM:"New Mexico", NV:"Nevada", NY:"New York", OH:"Ohio", OK:"Oklahoma", OR:"Oregon",
      PA:"Pennsylvania", RI:"Rhode Island", SC:"South Carolina", SD:"South Dakota", TN:"Tennessee", TX:"Texas",
      UT:"Utah", VA:"Virginia", VT:"Vermont", WA:"Washington", WI:"Wisconsin", WV:"West Virginia", WY:"Wyoming"
    };

    // Time helpers for sunrise/sunset
    function __tzLocalISOToUTC(isoLocal, utcOffsetSeconds) {
      try {
        const [d, t] = isoLocal.split('T');
        const [Y, M, D] = d.split('-').map(Number);
        const [h, m] = t.split(':').map(Number);
        return new Date(Date.UTC(Y, M - 1, D, h, m) - (utcOffsetSeconds || 0) * 1000);
      } catch { return null; }
    }
    function __fmtTimeInTZ(dateUTC, tz) {
      try {
        return new Intl.DateTimeFormat([], { hour: '2-digit', minute: '2-digit', timeZone: tz }).format(dateUTC);
      } catch { return '—'; }
    }

    function weatherDescription(code) {
      const map = {
        0:"Clear",1:"Mainly clear",2:"Partly cloudy",3:"Overcast",
        45:"Fog",48:"Rime fog",
        51:"Drizzle: Light",53:"Drizzle: Moderate",55:"Drizzle: Dense",
        56:"Freezing drizzle: Light",57:"Freezing drizzle: Dense",
        61:"Rain: Slight",63:"Rain: Moderate",65:"Rain: Heavy",
        66:"Freezing rain: Light",67:"Freezing rain: Heavy",
        71:"Snow: Slight",73:"Snow: Moderate",75:"Snow: Heavy",
        77:"Snow grains",
        80:"Rain showers: Slight",81:"Rain showers: Moderate",82:"Rain showers: Violent",
        85:"Snow showers: Slight",86:"Snow showers: Heavy",
        95:"Thunderstorm",96:"Thunderstorm w/ slight hail",99:"Thunderstorm w/ heavy hail"
      };
      return map[code] || "Unknown";
    }

    function showForecastError(msg) {
      const section = document.getElementById('forecast-section');
      const grid = document.getElementById('forecast-grid');
      const narrative = document.getElementById('forecast-narrative');
      grid.innerHTML = '';
      narrative.innerHTML = msg || 'Weather forecast not available.';
      section.style.display = 'block';
    }

    // Use City+State → Open-Meteo Geocoding → Forecast
    async function getLatLonFromCityState(city, stateAbbr) {
      try {
        const admin1 = STATE_NAME[stateAbbr?.toUpperCase?.()] || '';
        const url = new URL('https://geocoding-api.open-meteo.com/v1/search');
        url.searchParams.set('name', city);
        url.searchParams.set('count', '10');
        url.searchParams.set('language', 'en');
        url.searchParams.set('format', 'json');
        url.searchParams.set('filter', 'us'); // US focus

        const res = await fetch(url.toString());
        const data = await res.json();
        const hits = data?.results || [];

        // Prefer exact admin1 (state) and US
        let best = hits.find(r => r.country_code === 'US' && r.admin1 === admin1);
        if (!best) best = hits.find(r => r.country_code === 'US');
        if (!best) best = hits[0];
        if (!best) return null;

        return { lat: best.latitude, lon: best.longitude, tz: best.timezone };
      } catch { return null; }
    }

    async function renderForecast(lat, lon, label) {
      const section = document.getElementById('forecast-section');
      const grid = document.getElementById('forecast-grid');
      const narrative = document.getElementById('forecast-narrative');

      const url = new URL('https://api.open-meteo.com/v1/forecast');
      url.searchParams.set('latitude', lat);
      url.searchParams.set('longitude', lon);
      url.searchParams.set('timezone', 'auto');
      url.searchParams.set('temperature_unit', 'fahrenheit');
      url.searchParams.set('pressure_unit', 'hPa');
      url.searchParams.set('precipitation_unit', 'inch');
      url.searchParams.set('forecast_days', '3');
      url.searchParams.set('daily', 'temperature_2m_max,temperature_2m_min,sunrise,sunset,weathercode,precipitation_probability_max,precipitation_sum');
      url.searchParams.set('hourly', 'pressure_msl');

      let data;
      try {
        const res = await fetch(url.toString());
        data = await res.json();
      } catch {
        showForecastError('Unable to load weather forecast.');
        return;
      }
      if (!data?.daily?.time?.length) {
        showForecastError('Weather forecast not available.');
        return;
      }

      const tz = data.timezone || 'UTC';
      const ofs = data.utc_offset_seconds || 0;

      section.style.display = 'block';
      grid.innerHTML = '';
      narrative.innerHTML = '';

      const {
        time, temperature_2m_max: tMax, temperature_2m_min: tMin,
        sunrise, sunset, weathercode: wCode,
        precipitation_probability_max: pProb, precipitation_sum: pSum
      } = data.daily;

      const pTimes = data?.hourly?.time || [];
      const pVals  = data?.hourly?.pressure_msl || [];
      const dayAvgInHg = time.map(dayStr => {
        let total = 0, cnt = 0;
        for (let i=0;i<pTimes.length;i++) if (pTimes[i].startsWith(dayStr)) { total += pVals[i]; cnt++; }
        const hPa = cnt ? total/cnt : null;
        return hPa ? (hPa/33.8639).toFixed(2) : '—';
      });

      const pieces = [];
      for (let i=0;i<time.length;i++) {
        const dateLabel = new Date(time[i]).toLocaleDateString([], { weekday:'short', month:'short', day:'numeric' });
        const desc = weatherDescription(wCode[i]);
        const hi = Math.round(tMax[i]);
        const lo = Math.round(tMin[i]);
        const prob = (pProb?.[i] ?? '—');
        const precip = (pSum?.[i] ?? '—');

        const srUTC = __tzLocalISOToUTC(sunrise[i], ofs);
        const ssUTC = __tzLocalISOToUTC(sunset[i], ofs);
        const sr = srUTC ? __fmtTimeInTZ(srUTC, tz) : '—';
        const ss = ssUTC ? __fmtTimeInTZ(ssUTC, tz) : '—';

        const pinhg = dayAvgInHg[i];

        grid.innerHTML += `
          <div class="forecast-card">
            <h4>${dateLabel}</h4>
            <div class="forecast-line">Sky: ${desc}</div>
            <div class="forecast-line">High / Low: ${hi}°F / ${lo}°F</div>
            <div class="forecast-line">Barometric Pressure: ${pinhg} inHg</div>
            <div class="forecast-line">Sunrise: ${sr} &nbsp;•&nbsp; Sunset: ${ss}</div>
            <div class="forecast-line">Precip: ${precip} in &nbsp; (Max Prob: ${prob === '—' ? '—' : prob + '%'})</div>
          </div>
        `;
        pieces.push(`${i===0?'Today':i===1?'Tomorrow':dateLabel}: ${desc.toLowerCase()} with a high near ${hi}°F and a low around ${lo}°F. Average barometric pressure ~${pinhg} inHg. Precipitation total ${precip} in (max probability ${prob==='—'?'N/A':prob+'%'}). Sunrise ${sr}, sunset ${ss}.`);
      }

      const locText = label ? ` near <strong>${label}</strong>` : '';
      narrative.innerHTML = `<strong>Outlook${locText}:</strong> ${pieces.join(' ')}`;
    }

    // Weather entrypoint — called by Search button
    document.addEventListener('DOMContentLoaded', () => {
      const btn = document.getElementById('search-btn');
      if (btn) btn.addEventListener('click', async () => {
        const siteId = document.getElementById('station-select').value;
        if (!siteId) return;

        // Prefer city/state from the prebuilt JSON index
        let city = '', state = '', label = '';
        if (window.__stationIndexById && window.__stationIndexById[siteId]) {
          const rec = window.__stationIndexById[siteId];
          city = (rec.city || '').trim();
          state = (rec.state || '').trim();
          if (city && state) label = `${city}, ${state}`;
          else label = rec.name || '';
        }

        // If JSON missing, try parsing from station name (AT/NEAR City, ST)
        if ((!city || !state) && window.__stationIndexById && window.__stationIndexById[siteId]) {
          const nm = window.__stationIndexById[siteId].name || '';
          const m = nm.match(/\b(?:AT|NEAR|NR|ABOVE|BELOW)\s+([^,]+),\s*([A-Z]{2})\b/i);
          if (m) { city = m[1].trim(); state = m[2].toUpperCase(); label = `${city}, ${state}`; }
        }

        // If still missing, fall back to USGS metadata
        if (!city || !state) {
          try {
            const metaRes = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=json&sites=${siteId}`);
            const meta = await metaRes.json();
            const s = (meta?.value?.site?.[0]) || (meta?.value?.timeSeries?.[0]?.sourceInfo);
            const nm = s?.siteName || '';
            const sm = nm.match(/\b(?:AT|NEAR|NR|ABOVE|BELOW)\s+([^,]+),\s*([A-Z]{2})\b/i);
            if (sm) { city = sm[1].trim(); state = sm[2].toUpperCase(); label = `${city}, ${state}`; }
            if (!state) state = s?.siteProperty?.find(p=>p.name==="stateCd")?.value || state;
          } catch {}
        }

        // Resolve city+state to lat/lon via geocoding; render
        if (city && state) {
          const geo = await getLatLonFromCityState(city, state);
          if (geo?.lat != null && geo?.lon != null) {
            await renderForecast(geo.lat, geo.lon, label || `${city}, ${state}`);
            return;
          }
        }

        // Final fallback: old lat/lon resolver if everything else failed
        try {
          const r1 = await fetch(`https://waterservices.usgs.gov/nwis/site/?format=json&sites=${siteId}`);
          const j1 = await r1.json();
          const s1 = (j1?.value?.site?.[0]) || (j1?.value?.timeSeries?.[0]?.sourceInfo);
          const g1 = s1?.geoLocation?.geogLocation;
          if (g1?.latitude != null && g1?.longitude != null) {
            await renderForecast(g1.latitude, g1.longitude, label || (s1?.siteName || ''));
            return;
          }
        } catch {}

        showForecastError('Weather forecast not available.');
      });
    });
  </script>

  <!-- GLOBAL SEARCH powered by your JSON (full load + ETA; no flicker) -->
  <script>
    // EDIT THIS if your JSON lives at a different path:
    const STATIONS_JSON_URL = "https://drivebyluck.github.io/mccoy.fish/data/stations.min.json";

    // Structures
    window.__globalStations = [];            // for keyword matching
    window.__stationIndexById = Object.create(null); // fast by site id
    let __indexReady = false;

    // Wire search UI
    document.addEventListener('DOMContentLoaded', () => {
      const input = document.getElementById('global-search');
      const box = document.getElementById('global-results');
      if (!input || !box) return;

      // progress UI
      const prog = document.createElement('div');
      prog.id = 'global-progress';
      prog.innerHTML = `
        <div class="mccoy-progress-wrap"><div class="mccoy-progress-bar" id="global-progress-bar"></div></div>
        <div class="mccoy-progress-text" id="global-progress-text">Preparing station index…</div>
      `;
      box.appendChild(prog);

      // Don’t show items until index is ready — just keep the box open with progress
      input.addEventListener('focus', () => { box.style.display = 'block'; if (__indexReady) renderGlobalMatches(input.value.trim()); });
      input.addEventListener('input', () => { box.style.display = 'block'; if (__indexReady) renderGlobalMatches(input.value.trim()); });

      document.addEventListener('click', (e) => { if (!box.contains(e.target) && e.target !== input) box.style.display = 'none'; });

      // Start loading the JSON index with real-time progress + ETA
      preloadStationsJSONWithProgress().catch(() => {
        const t = document.getElementById('global-progress-text');
        if (t) t.textContent = 'Failed to load station index. Refresh to try again.';
      });
    });

    // Stream + progress + ETA
    async function preloadStationsJSONWithProgress() {
      const bar = document.getElementById('global-progress-bar');
      const txt = document.getElementById('global-progress-text');

      const res = await fetch(STATIONS_JSON_URL, { cache: 'force-cache' });
      if (!res.ok) throw new Error('JSON fetch failed: ' + res.status);

      const total = Number(res.headers.get('Content-Length') || 0);
      const reader = res.body.getReader();
      const decoder = new TextDecoder();
      let received = 0;
      let chunks = '';
      const start = performance.now();

      const update = () => {
        if (!total) {
          if (txt) txt.textContent = 'Loading station index…';
          return;
        }
        const pct = Math.max(0, Math.min(100, (received / total) * 100));
        const elapsed = (performance.now() - start) / 1000;
        const rate = received / Math.max(elapsed, 0.001); // bytes/sec
        const remainingSec = (total - received) / Math.max(rate, 1);
        if (bar) bar.style.width = pct.toFixed(0) + '%';
        if (txt) txt.textContent = `Loading station index… ${pct.toFixed(0)}% — ~${Math.max(0, Math.round(remainingSec))}s left`;
      };

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        received += value.byteLength;
        chunks += decoder.decode(value, { stream: true });
        update();
      }
      chunks += decoder.decode();

      // Parse once fully received (no partial rendering → no flicker)
      const list = JSON.parse(chunks);

      // Build indices
      for (const r of list) {
        window.__stationIndexById[r.site_no] = r; // expects {site_no, name, state, city, lat, lon}
      }
      window.__globalStations = list.map(r => ({ id: r.site_no, name: r.name, state: r.state, city: r.city, lat: r.lat, lon: r.lon }));
      window.__globalStations.sort((a,b)=>a.name.localeCompare(b.name));

      __indexReady = true;

      // Hide progress; show matches if the user is typing
      const box = document.getElementById('global-results');
      const input = document.getElementById('global-search');
      const prog = document.getElementById('global-progress');
      if (prog) prog.style.display = 'none';
      if (box && input && input.value.trim()) {
        box.style.display = 'block';
        renderGlobalMatches(input.value.trim());
      }
    }

    function renderGlobalMatches(query) {
      const box = document.getElementById('global-results');
      if (!box) return;

      if (!__indexReady) {
        box.style.display = 'block';
        return; // only show progress until ready
      }

      if (!query) { box.style.display = 'none'; return; }
      const q = query.toLowerCase();
      const matches = window.__globalStations.filter(s => (s.name || '').toLowerCase().includes(q)).slice(0, 100);

      // rebuild the list
      box.innerHTML = '';
      if (!matches.length) {
        const d = document.createElement('div');
        d.className = 'empty';
        d.textContent = 'No matches.';
        box.appendChild(d);
        return;
      }

      for (const m of matches) {
        const div = document.createElement('div');
        div.className = 'global-result-item';
        div.textContent = `${m.name}  [${m.state}]`;
        div.addEventListener('click', () => handleGlobalPick(m));
        box.appendChild(div);
      }
    }

    async function handleGlobalPick(station) {
      try {
        await loadStationsForState(station.state);
        const stationSelect = document.getElementById('station-select');
        const searchBtn = document.getElementById('search-btn');
        stationSelect.value = station.id;
        searchBtn.disabled = stationSelect.value === "";
        searchBtn.click();
      } catch (e) {
        console.warn('Global pick failed:', e);
      } finally {
        const box = document.getElementById('global-results');
        if (box) box.style.display = 'none';
      }
    }
  </script>
</body>
</html>
